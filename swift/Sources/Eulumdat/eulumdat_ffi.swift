// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(eulumdat_ffiFFI)
import eulumdat_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_eulumdat_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_eulumdat_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


/**
 * Complete BUG diagram data
 */
public struct BugDiagramData {
    public var zones: ZoneLumens
    public var rating: BugRatingData
    public var totalLumens: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(zones: ZoneLumens, rating: BugRatingData, totalLumens: Double) {
        self.zones = zones
        self.rating = rating
        self.totalLumens = totalLumens
    }
}



extension BugDiagramData: Equatable, Hashable {
    public static func ==(lhs: BugDiagramData, rhs: BugDiagramData) -> Bool {
        if lhs.zones != rhs.zones {
            return false
        }
        if lhs.rating != rhs.rating {
            return false
        }
        if lhs.totalLumens != rhs.totalLumens {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(zones)
        hasher.combine(rating)
        hasher.combine(totalLumens)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBugDiagramData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BugDiagramData {
        return
            try BugDiagramData(
                zones: FfiConverterTypeZoneLumens.read(from: &buf), 
                rating: FfiConverterTypeBugRatingData.read(from: &buf), 
                totalLumens: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: BugDiagramData, into buf: inout [UInt8]) {
        FfiConverterTypeZoneLumens.write(value.zones, into: &buf)
        FfiConverterTypeBugRatingData.write(value.rating, into: &buf)
        FfiConverterDouble.write(value.totalLumens, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBugDiagramData_lift(_ buf: RustBuffer) throws -> BugDiagramData {
    return try FfiConverterTypeBugDiagramData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBugDiagramData_lower(_ value: BugDiagramData) -> RustBuffer {
    return FfiConverterTypeBugDiagramData.lower(value)
}


/**
 * BUG rating values (0-5 scale)
 */
public struct BugRatingData {
    public var b: UInt8
    public var u: UInt8
    public var g: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(b: UInt8, u: UInt8, g: UInt8) {
        self.b = b
        self.u = u
        self.g = g
    }
}



extension BugRatingData: Equatable, Hashable {
    public static func ==(lhs: BugRatingData, rhs: BugRatingData) -> Bool {
        if lhs.b != rhs.b {
            return false
        }
        if lhs.u != rhs.u {
            return false
        }
        if lhs.g != rhs.g {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(b)
        hasher.combine(u)
        hasher.combine(g)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBugRatingData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BugRatingData {
        return
            try BugRatingData(
                b: FfiConverterUInt8.read(from: &buf), 
                u: FfiConverterUInt8.read(from: &buf), 
                g: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: BugRatingData, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.b, into: &buf)
        FfiConverterUInt8.write(value.u, into: &buf)
        FfiConverterUInt8.write(value.g, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBugRatingData_lift(_ buf: RustBuffer) throws -> BugRatingData {
    return try FfiConverterTypeBugRatingData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBugRatingData_lower(_ value: BugRatingData) -> RustBuffer {
    return FfiConverterTypeBugRatingData.lower(value)
}


public struct ButterflyDiagramData {
    public var wings: [ButterflyWing]
    public var gridCircles: [[Point2D]]
    public var cPlaneLines: [CPlaneDirection]
    public var scale: DiagramScale
    public var gAngles: [Double]
    public var symmetry: Symmetry

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(wings: [ButterflyWing], gridCircles: [[Point2D]], cPlaneLines: [CPlaneDirection], scale: DiagramScale, gAngles: [Double], symmetry: Symmetry) {
        self.wings = wings
        self.gridCircles = gridCircles
        self.cPlaneLines = cPlaneLines
        self.scale = scale
        self.gAngles = gAngles
        self.symmetry = symmetry
    }
}



extension ButterflyDiagramData: Equatable, Hashable {
    public static func ==(lhs: ButterflyDiagramData, rhs: ButterflyDiagramData) -> Bool {
        if lhs.wings != rhs.wings {
            return false
        }
        if lhs.gridCircles != rhs.gridCircles {
            return false
        }
        if lhs.cPlaneLines != rhs.cPlaneLines {
            return false
        }
        if lhs.scale != rhs.scale {
            return false
        }
        if lhs.gAngles != rhs.gAngles {
            return false
        }
        if lhs.symmetry != rhs.symmetry {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(wings)
        hasher.combine(gridCircles)
        hasher.combine(cPlaneLines)
        hasher.combine(scale)
        hasher.combine(gAngles)
        hasher.combine(symmetry)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeButterflyDiagramData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ButterflyDiagramData {
        return
            try ButterflyDiagramData(
                wings: FfiConverterSequenceTypeButterflyWing.read(from: &buf), 
                gridCircles: FfiConverterSequenceSequenceTypePoint2D.read(from: &buf), 
                cPlaneLines: FfiConverterSequenceTypeCPlaneDirection.read(from: &buf), 
                scale: FfiConverterTypeDiagramScale.read(from: &buf), 
                gAngles: FfiConverterSequenceDouble.read(from: &buf), 
                symmetry: FfiConverterTypeSymmetry.read(from: &buf)
        )
    }

    public static func write(_ value: ButterflyDiagramData, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeButterflyWing.write(value.wings, into: &buf)
        FfiConverterSequenceSequenceTypePoint2D.write(value.gridCircles, into: &buf)
        FfiConverterSequenceTypeCPlaneDirection.write(value.cPlaneLines, into: &buf)
        FfiConverterTypeDiagramScale.write(value.scale, into: &buf)
        FfiConverterSequenceDouble.write(value.gAngles, into: &buf)
        FfiConverterTypeSymmetry.write(value.symmetry, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeButterflyDiagramData_lift(_ buf: RustBuffer) throws -> ButterflyDiagramData {
    return try FfiConverterTypeButterflyDiagramData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeButterflyDiagramData_lower(_ value: ButterflyDiagramData) -> RustBuffer {
    return FfiConverterTypeButterflyDiagramData.lower(value)
}


public struct ButterflyWing {
    public var cAngle: Double
    public var points: [Point2D]
    public var fillColor: Color
    public var strokeColor: Color
    public var svgPath: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cAngle: Double, points: [Point2D], fillColor: Color, strokeColor: Color, svgPath: String) {
        self.cAngle = cAngle
        self.points = points
        self.fillColor = fillColor
        self.strokeColor = strokeColor
        self.svgPath = svgPath
    }
}



extension ButterflyWing: Equatable, Hashable {
    public static func ==(lhs: ButterflyWing, rhs: ButterflyWing) -> Bool {
        if lhs.cAngle != rhs.cAngle {
            return false
        }
        if lhs.points != rhs.points {
            return false
        }
        if lhs.fillColor != rhs.fillColor {
            return false
        }
        if lhs.strokeColor != rhs.strokeColor {
            return false
        }
        if lhs.svgPath != rhs.svgPath {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cAngle)
        hasher.combine(points)
        hasher.combine(fillColor)
        hasher.combine(strokeColor)
        hasher.combine(svgPath)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeButterflyWing: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ButterflyWing {
        return
            try ButterflyWing(
                cAngle: FfiConverterDouble.read(from: &buf), 
                points: FfiConverterSequenceTypePoint2D.read(from: &buf), 
                fillColor: FfiConverterTypeColor.read(from: &buf), 
                strokeColor: FfiConverterTypeColor.read(from: &buf), 
                svgPath: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ButterflyWing, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.cAngle, into: &buf)
        FfiConverterSequenceTypePoint2D.write(value.points, into: &buf)
        FfiConverterTypeColor.write(value.fillColor, into: &buf)
        FfiConverterTypeColor.write(value.strokeColor, into: &buf)
        FfiConverterString.write(value.svgPath, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeButterflyWing_lift(_ buf: RustBuffer) throws -> ButterflyWing {
    return try FfiConverterTypeButterflyWing.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeButterflyWing_lower(_ value: ButterflyWing) -> RustBuffer {
    return FfiConverterTypeButterflyWing.lower(value)
}


public struct CPlaneDirection {
    public var angle: Double
    public var start: Point2D
    public var endPoint: Point2D

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(angle: Double, start: Point2D, endPoint: Point2D) {
        self.angle = angle
        self.start = start
        self.endPoint = endPoint
    }
}



extension CPlaneDirection: Equatable, Hashable {
    public static func ==(lhs: CPlaneDirection, rhs: CPlaneDirection) -> Bool {
        if lhs.angle != rhs.angle {
            return false
        }
        if lhs.start != rhs.start {
            return false
        }
        if lhs.endPoint != rhs.endPoint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(angle)
        hasher.combine(start)
        hasher.combine(endPoint)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCPlaneDirection: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CPlaneDirection {
        return
            try CPlaneDirection(
                angle: FfiConverterDouble.read(from: &buf), 
                start: FfiConverterTypePoint2D.read(from: &buf), 
                endPoint: FfiConverterTypePoint2D.read(from: &buf)
        )
    }

    public static func write(_ value: CPlaneDirection, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.angle, into: &buf)
        FfiConverterTypePoint2D.write(value.start, into: &buf)
        FfiConverterTypePoint2D.write(value.endPoint, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCPlaneDirection_lift(_ buf: RustBuffer) throws -> CPlaneDirection {
    return try FfiConverterTypeCPlaneDirection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCPlaneDirection_lower(_ value: CPlaneDirection) -> RustBuffer {
    return FfiConverterTypeCPlaneDirection.lower(value)
}


public struct CartesianCurve {
    public var points: [CartesianPoint]
    public var cAngle: Double
    public var color: Color
    public var label: String
    public var svgPath: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(points: [CartesianPoint], cAngle: Double, color: Color, label: String, svgPath: String) {
        self.points = points
        self.cAngle = cAngle
        self.color = color
        self.label = label
        self.svgPath = svgPath
    }
}



extension CartesianCurve: Equatable, Hashable {
    public static func ==(lhs: CartesianCurve, rhs: CartesianCurve) -> Bool {
        if lhs.points != rhs.points {
            return false
        }
        if lhs.cAngle != rhs.cAngle {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.svgPath != rhs.svgPath {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(points)
        hasher.combine(cAngle)
        hasher.combine(color)
        hasher.combine(label)
        hasher.combine(svgPath)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCartesianCurve: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CartesianCurve {
        return
            try CartesianCurve(
                points: FfiConverterSequenceTypeCartesianPoint.read(from: &buf), 
                cAngle: FfiConverterDouble.read(from: &buf), 
                color: FfiConverterTypeColor.read(from: &buf), 
                label: FfiConverterString.read(from: &buf), 
                svgPath: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CartesianCurve, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeCartesianPoint.write(value.points, into: &buf)
        FfiConverterDouble.write(value.cAngle, into: &buf)
        FfiConverterTypeColor.write(value.color, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
        FfiConverterString.write(value.svgPath, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCartesianCurve_lift(_ buf: RustBuffer) throws -> CartesianCurve {
    return try FfiConverterTypeCartesianCurve.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCartesianCurve_lower(_ value: CartesianCurve) -> RustBuffer {
    return FfiConverterTypeCartesianCurve.lower(value)
}


public struct CartesianDiagramData {
    public var curves: [CartesianCurve]
    public var xTicks: [Double]
    public var yTicks: [Double]
    public var scale: DiagramScale
    public var maxGamma: Double
    public var plotWidth: Double
    public var plotHeight: Double
    public var marginLeft: Double
    public var marginTop: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(curves: [CartesianCurve], xTicks: [Double], yTicks: [Double], scale: DiagramScale, maxGamma: Double, plotWidth: Double, plotHeight: Double, marginLeft: Double, marginTop: Double) {
        self.curves = curves
        self.xTicks = xTicks
        self.yTicks = yTicks
        self.scale = scale
        self.maxGamma = maxGamma
        self.plotWidth = plotWidth
        self.plotHeight = plotHeight
        self.marginLeft = marginLeft
        self.marginTop = marginTop
    }
}



extension CartesianDiagramData: Equatable, Hashable {
    public static func ==(lhs: CartesianDiagramData, rhs: CartesianDiagramData) -> Bool {
        if lhs.curves != rhs.curves {
            return false
        }
        if lhs.xTicks != rhs.xTicks {
            return false
        }
        if lhs.yTicks != rhs.yTicks {
            return false
        }
        if lhs.scale != rhs.scale {
            return false
        }
        if lhs.maxGamma != rhs.maxGamma {
            return false
        }
        if lhs.plotWidth != rhs.plotWidth {
            return false
        }
        if lhs.plotHeight != rhs.plotHeight {
            return false
        }
        if lhs.marginLeft != rhs.marginLeft {
            return false
        }
        if lhs.marginTop != rhs.marginTop {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(curves)
        hasher.combine(xTicks)
        hasher.combine(yTicks)
        hasher.combine(scale)
        hasher.combine(maxGamma)
        hasher.combine(plotWidth)
        hasher.combine(plotHeight)
        hasher.combine(marginLeft)
        hasher.combine(marginTop)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCartesianDiagramData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CartesianDiagramData {
        return
            try CartesianDiagramData(
                curves: FfiConverterSequenceTypeCartesianCurve.read(from: &buf), 
                xTicks: FfiConverterSequenceDouble.read(from: &buf), 
                yTicks: FfiConverterSequenceDouble.read(from: &buf), 
                scale: FfiConverterTypeDiagramScale.read(from: &buf), 
                maxGamma: FfiConverterDouble.read(from: &buf), 
                plotWidth: FfiConverterDouble.read(from: &buf), 
                plotHeight: FfiConverterDouble.read(from: &buf), 
                marginLeft: FfiConverterDouble.read(from: &buf), 
                marginTop: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: CartesianDiagramData, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeCartesianCurve.write(value.curves, into: &buf)
        FfiConverterSequenceDouble.write(value.xTicks, into: &buf)
        FfiConverterSequenceDouble.write(value.yTicks, into: &buf)
        FfiConverterTypeDiagramScale.write(value.scale, into: &buf)
        FfiConverterDouble.write(value.maxGamma, into: &buf)
        FfiConverterDouble.write(value.plotWidth, into: &buf)
        FfiConverterDouble.write(value.plotHeight, into: &buf)
        FfiConverterDouble.write(value.marginLeft, into: &buf)
        FfiConverterDouble.write(value.marginTop, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCartesianDiagramData_lift(_ buf: RustBuffer) throws -> CartesianDiagramData {
    return try FfiConverterTypeCartesianDiagramData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCartesianDiagramData_lower(_ value: CartesianDiagramData) -> RustBuffer {
    return FfiConverterTypeCartesianDiagramData.lower(value)
}


public struct CartesianPoint {
    public var x: Double
    public var y: Double
    public var gamma: Double
    public var intensity: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(x: Double, y: Double, gamma: Double, intensity: Double) {
        self.x = x
        self.y = y
        self.gamma = gamma
        self.intensity = intensity
    }
}



extension CartesianPoint: Equatable, Hashable {
    public static func ==(lhs: CartesianPoint, rhs: CartesianPoint) -> Bool {
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        if lhs.gamma != rhs.gamma {
            return false
        }
        if lhs.intensity != rhs.intensity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x)
        hasher.combine(y)
        hasher.combine(gamma)
        hasher.combine(intensity)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCartesianPoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CartesianPoint {
        return
            try CartesianPoint(
                x: FfiConverterDouble.read(from: &buf), 
                y: FfiConverterDouble.read(from: &buf), 
                gamma: FfiConverterDouble.read(from: &buf), 
                intensity: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: CartesianPoint, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.x, into: &buf)
        FfiConverterDouble.write(value.y, into: &buf)
        FfiConverterDouble.write(value.gamma, into: &buf)
        FfiConverterDouble.write(value.intensity, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCartesianPoint_lift(_ buf: RustBuffer) throws -> CartesianPoint {
    return try FfiConverterTypeCartesianPoint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCartesianPoint_lower(_ value: CartesianPoint) -> RustBuffer {
    return FfiConverterTypeCartesianPoint.lower(value)
}


public struct Color {
    public var r: UInt8
    public var g: UInt8
    public var b: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(r: UInt8, g: UInt8, b: UInt8) {
        self.r = r
        self.g = g
        self.b = b
    }
}



extension Color: Equatable, Hashable {
    public static func ==(lhs: Color, rhs: Color) -> Bool {
        if lhs.r != rhs.r {
            return false
        }
        if lhs.g != rhs.g {
            return false
        }
        if lhs.b != rhs.b {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(r)
        hasher.combine(g)
        hasher.combine(b)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeColor: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Color {
        return
            try Color(
                r: FfiConverterUInt8.read(from: &buf), 
                g: FfiConverterUInt8.read(from: &buf), 
                b: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: Color, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.r, into: &buf)
        FfiConverterUInt8.write(value.g, into: &buf)
        FfiConverterUInt8.write(value.b, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColor_lift(_ buf: RustBuffer) throws -> Color {
    return try FfiConverterTypeColor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColor_lower(_ value: Color) -> RustBuffer {
    return FfiConverterTypeColor.lower(value)
}


public struct DiagramScale {
    public var maxIntensity: Double
    public var scaleMax: Double
    public var gridValues: [Double]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxIntensity: Double, scaleMax: Double, gridValues: [Double]) {
        self.maxIntensity = maxIntensity
        self.scaleMax = scaleMax
        self.gridValues = gridValues
    }
}



extension DiagramScale: Equatable, Hashable {
    public static func ==(lhs: DiagramScale, rhs: DiagramScale) -> Bool {
        if lhs.maxIntensity != rhs.maxIntensity {
            return false
        }
        if lhs.scaleMax != rhs.scaleMax {
            return false
        }
        if lhs.gridValues != rhs.gridValues {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxIntensity)
        hasher.combine(scaleMax)
        hasher.combine(gridValues)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDiagramScale: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DiagramScale {
        return
            try DiagramScale(
                maxIntensity: FfiConverterDouble.read(from: &buf), 
                scaleMax: FfiConverterDouble.read(from: &buf), 
                gridValues: FfiConverterSequenceDouble.read(from: &buf)
        )
    }

    public static func write(_ value: DiagramScale, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.maxIntensity, into: &buf)
        FfiConverterDouble.write(value.scaleMax, into: &buf)
        FfiConverterSequenceDouble.write(value.gridValues, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDiagramScale_lift(_ buf: RustBuffer) throws -> DiagramScale {
    return try FfiConverterTypeDiagramScale.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDiagramScale_lower(_ value: DiagramScale) -> RustBuffer {
    return FfiConverterTypeDiagramScale.lower(value)
}


public struct Eulumdat {
    public var identification: String
    public var typeIndicator: TypeIndicator
    public var symmetry: Symmetry
    public var numCPlanes: UInt32
    public var cPlaneDistance: Double
    public var numGPlanes: UInt32
    public var gPlaneDistance: Double
    public var measurementReportNumber: String
    public var luminaireName: String
    public var luminaireNumber: String
    public var fileName: String
    public var dateUser: String
    public var length: Double
    public var width: Double
    public var height: Double
    public var luminousAreaLength: Double
    public var luminousAreaWidth: Double
    public var heightC0: Double
    public var heightC90: Double
    public var heightC180: Double
    public var heightC270: Double
    public var downwardFluxFraction: Double
    public var lightOutputRatio: Double
    public var conversionFactor: Double
    public var tiltAngle: Double
    public var lampSets: [LampSet]
    public var directRatios: [Double]
    public var cAngles: [Double]
    public var gAngles: [Double]
    public var intensities: [[Double]]
    public var maxIntensity: Double
    public var totalLuminousFlux: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identification: String, typeIndicator: TypeIndicator, symmetry: Symmetry, numCPlanes: UInt32, cPlaneDistance: Double, numGPlanes: UInt32, gPlaneDistance: Double, measurementReportNumber: String, luminaireName: String, luminaireNumber: String, fileName: String, dateUser: String, length: Double, width: Double, height: Double, luminousAreaLength: Double, luminousAreaWidth: Double, heightC0: Double, heightC90: Double, heightC180: Double, heightC270: Double, downwardFluxFraction: Double, lightOutputRatio: Double, conversionFactor: Double, tiltAngle: Double, lampSets: [LampSet], directRatios: [Double], cAngles: [Double], gAngles: [Double], intensities: [[Double]], maxIntensity: Double, totalLuminousFlux: Double) {
        self.identification = identification
        self.typeIndicator = typeIndicator
        self.symmetry = symmetry
        self.numCPlanes = numCPlanes
        self.cPlaneDistance = cPlaneDistance
        self.numGPlanes = numGPlanes
        self.gPlaneDistance = gPlaneDistance
        self.measurementReportNumber = measurementReportNumber
        self.luminaireName = luminaireName
        self.luminaireNumber = luminaireNumber
        self.fileName = fileName
        self.dateUser = dateUser
        self.length = length
        self.width = width
        self.height = height
        self.luminousAreaLength = luminousAreaLength
        self.luminousAreaWidth = luminousAreaWidth
        self.heightC0 = heightC0
        self.heightC90 = heightC90
        self.heightC180 = heightC180
        self.heightC270 = heightC270
        self.downwardFluxFraction = downwardFluxFraction
        self.lightOutputRatio = lightOutputRatio
        self.conversionFactor = conversionFactor
        self.tiltAngle = tiltAngle
        self.lampSets = lampSets
        self.directRatios = directRatios
        self.cAngles = cAngles
        self.gAngles = gAngles
        self.intensities = intensities
        self.maxIntensity = maxIntensity
        self.totalLuminousFlux = totalLuminousFlux
    }
}



extension Eulumdat: Equatable, Hashable {
    public static func ==(lhs: Eulumdat, rhs: Eulumdat) -> Bool {
        if lhs.identification != rhs.identification {
            return false
        }
        if lhs.typeIndicator != rhs.typeIndicator {
            return false
        }
        if lhs.symmetry != rhs.symmetry {
            return false
        }
        if lhs.numCPlanes != rhs.numCPlanes {
            return false
        }
        if lhs.cPlaneDistance != rhs.cPlaneDistance {
            return false
        }
        if lhs.numGPlanes != rhs.numGPlanes {
            return false
        }
        if lhs.gPlaneDistance != rhs.gPlaneDistance {
            return false
        }
        if lhs.measurementReportNumber != rhs.measurementReportNumber {
            return false
        }
        if lhs.luminaireName != rhs.luminaireName {
            return false
        }
        if lhs.luminaireNumber != rhs.luminaireNumber {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.dateUser != rhs.dateUser {
            return false
        }
        if lhs.length != rhs.length {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        if lhs.luminousAreaLength != rhs.luminousAreaLength {
            return false
        }
        if lhs.luminousAreaWidth != rhs.luminousAreaWidth {
            return false
        }
        if lhs.heightC0 != rhs.heightC0 {
            return false
        }
        if lhs.heightC90 != rhs.heightC90 {
            return false
        }
        if lhs.heightC180 != rhs.heightC180 {
            return false
        }
        if lhs.heightC270 != rhs.heightC270 {
            return false
        }
        if lhs.downwardFluxFraction != rhs.downwardFluxFraction {
            return false
        }
        if lhs.lightOutputRatio != rhs.lightOutputRatio {
            return false
        }
        if lhs.conversionFactor != rhs.conversionFactor {
            return false
        }
        if lhs.tiltAngle != rhs.tiltAngle {
            return false
        }
        if lhs.lampSets != rhs.lampSets {
            return false
        }
        if lhs.directRatios != rhs.directRatios {
            return false
        }
        if lhs.cAngles != rhs.cAngles {
            return false
        }
        if lhs.gAngles != rhs.gAngles {
            return false
        }
        if lhs.intensities != rhs.intensities {
            return false
        }
        if lhs.maxIntensity != rhs.maxIntensity {
            return false
        }
        if lhs.totalLuminousFlux != rhs.totalLuminousFlux {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identification)
        hasher.combine(typeIndicator)
        hasher.combine(symmetry)
        hasher.combine(numCPlanes)
        hasher.combine(cPlaneDistance)
        hasher.combine(numGPlanes)
        hasher.combine(gPlaneDistance)
        hasher.combine(measurementReportNumber)
        hasher.combine(luminaireName)
        hasher.combine(luminaireNumber)
        hasher.combine(fileName)
        hasher.combine(dateUser)
        hasher.combine(length)
        hasher.combine(width)
        hasher.combine(height)
        hasher.combine(luminousAreaLength)
        hasher.combine(luminousAreaWidth)
        hasher.combine(heightC0)
        hasher.combine(heightC90)
        hasher.combine(heightC180)
        hasher.combine(heightC270)
        hasher.combine(downwardFluxFraction)
        hasher.combine(lightOutputRatio)
        hasher.combine(conversionFactor)
        hasher.combine(tiltAngle)
        hasher.combine(lampSets)
        hasher.combine(directRatios)
        hasher.combine(cAngles)
        hasher.combine(gAngles)
        hasher.combine(intensities)
        hasher.combine(maxIntensity)
        hasher.combine(totalLuminousFlux)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEulumdat: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Eulumdat {
        return
            try Eulumdat(
                identification: FfiConverterString.read(from: &buf), 
                typeIndicator: FfiConverterTypeTypeIndicator.read(from: &buf), 
                symmetry: FfiConverterTypeSymmetry.read(from: &buf), 
                numCPlanes: FfiConverterUInt32.read(from: &buf), 
                cPlaneDistance: FfiConverterDouble.read(from: &buf), 
                numGPlanes: FfiConverterUInt32.read(from: &buf), 
                gPlaneDistance: FfiConverterDouble.read(from: &buf), 
                measurementReportNumber: FfiConverterString.read(from: &buf), 
                luminaireName: FfiConverterString.read(from: &buf), 
                luminaireNumber: FfiConverterString.read(from: &buf), 
                fileName: FfiConverterString.read(from: &buf), 
                dateUser: FfiConverterString.read(from: &buf), 
                length: FfiConverterDouble.read(from: &buf), 
                width: FfiConverterDouble.read(from: &buf), 
                height: FfiConverterDouble.read(from: &buf), 
                luminousAreaLength: FfiConverterDouble.read(from: &buf), 
                luminousAreaWidth: FfiConverterDouble.read(from: &buf), 
                heightC0: FfiConverterDouble.read(from: &buf), 
                heightC90: FfiConverterDouble.read(from: &buf), 
                heightC180: FfiConverterDouble.read(from: &buf), 
                heightC270: FfiConverterDouble.read(from: &buf), 
                downwardFluxFraction: FfiConverterDouble.read(from: &buf), 
                lightOutputRatio: FfiConverterDouble.read(from: &buf), 
                conversionFactor: FfiConverterDouble.read(from: &buf), 
                tiltAngle: FfiConverterDouble.read(from: &buf), 
                lampSets: FfiConverterSequenceTypeLampSet.read(from: &buf), 
                directRatios: FfiConverterSequenceDouble.read(from: &buf), 
                cAngles: FfiConverterSequenceDouble.read(from: &buf), 
                gAngles: FfiConverterSequenceDouble.read(from: &buf), 
                intensities: FfiConverterSequenceSequenceDouble.read(from: &buf), 
                maxIntensity: FfiConverterDouble.read(from: &buf), 
                totalLuminousFlux: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Eulumdat, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identification, into: &buf)
        FfiConverterTypeTypeIndicator.write(value.typeIndicator, into: &buf)
        FfiConverterTypeSymmetry.write(value.symmetry, into: &buf)
        FfiConverterUInt32.write(value.numCPlanes, into: &buf)
        FfiConverterDouble.write(value.cPlaneDistance, into: &buf)
        FfiConverterUInt32.write(value.numGPlanes, into: &buf)
        FfiConverterDouble.write(value.gPlaneDistance, into: &buf)
        FfiConverterString.write(value.measurementReportNumber, into: &buf)
        FfiConverterString.write(value.luminaireName, into: &buf)
        FfiConverterString.write(value.luminaireNumber, into: &buf)
        FfiConverterString.write(value.fileName, into: &buf)
        FfiConverterString.write(value.dateUser, into: &buf)
        FfiConverterDouble.write(value.length, into: &buf)
        FfiConverterDouble.write(value.width, into: &buf)
        FfiConverterDouble.write(value.height, into: &buf)
        FfiConverterDouble.write(value.luminousAreaLength, into: &buf)
        FfiConverterDouble.write(value.luminousAreaWidth, into: &buf)
        FfiConverterDouble.write(value.heightC0, into: &buf)
        FfiConverterDouble.write(value.heightC90, into: &buf)
        FfiConverterDouble.write(value.heightC180, into: &buf)
        FfiConverterDouble.write(value.heightC270, into: &buf)
        FfiConverterDouble.write(value.downwardFluxFraction, into: &buf)
        FfiConverterDouble.write(value.lightOutputRatio, into: &buf)
        FfiConverterDouble.write(value.conversionFactor, into: &buf)
        FfiConverterDouble.write(value.tiltAngle, into: &buf)
        FfiConverterSequenceTypeLampSet.write(value.lampSets, into: &buf)
        FfiConverterSequenceDouble.write(value.directRatios, into: &buf)
        FfiConverterSequenceDouble.write(value.cAngles, into: &buf)
        FfiConverterSequenceDouble.write(value.gAngles, into: &buf)
        FfiConverterSequenceSequenceDouble.write(value.intensities, into: &buf)
        FfiConverterDouble.write(value.maxIntensity, into: &buf)
        FfiConverterDouble.write(value.totalLuminousFlux, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEulumdat_lift(_ buf: RustBuffer) throws -> Eulumdat {
    return try FfiConverterTypeEulumdat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEulumdat_lower(_ value: Eulumdat) -> RustBuffer {
    return FfiConverterTypeEulumdat.lower(value)
}


public struct HeatmapCell {
    public var cIndex: UInt32
    public var gIndex: UInt32
    public var cAngle: Double
    public var gAngle: Double
    public var intensity: Double
    public var candela: Double
    public var normalized: Double
    public var color: Color
    public var x: Double
    public var y: Double
    public var width: Double
    public var height: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cIndex: UInt32, gIndex: UInt32, cAngle: Double, gAngle: Double, intensity: Double, candela: Double, normalized: Double, color: Color, x: Double, y: Double, width: Double, height: Double) {
        self.cIndex = cIndex
        self.gIndex = gIndex
        self.cAngle = cAngle
        self.gAngle = gAngle
        self.intensity = intensity
        self.candela = candela
        self.normalized = normalized
        self.color = color
        self.x = x
        self.y = y
        self.width = width
        self.height = height
    }
}



extension HeatmapCell: Equatable, Hashable {
    public static func ==(lhs: HeatmapCell, rhs: HeatmapCell) -> Bool {
        if lhs.cIndex != rhs.cIndex {
            return false
        }
        if lhs.gIndex != rhs.gIndex {
            return false
        }
        if lhs.cAngle != rhs.cAngle {
            return false
        }
        if lhs.gAngle != rhs.gAngle {
            return false
        }
        if lhs.intensity != rhs.intensity {
            return false
        }
        if lhs.candela != rhs.candela {
            return false
        }
        if lhs.normalized != rhs.normalized {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cIndex)
        hasher.combine(gIndex)
        hasher.combine(cAngle)
        hasher.combine(gAngle)
        hasher.combine(intensity)
        hasher.combine(candela)
        hasher.combine(normalized)
        hasher.combine(color)
        hasher.combine(x)
        hasher.combine(y)
        hasher.combine(width)
        hasher.combine(height)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHeatmapCell: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HeatmapCell {
        return
            try HeatmapCell(
                cIndex: FfiConverterUInt32.read(from: &buf), 
                gIndex: FfiConverterUInt32.read(from: &buf), 
                cAngle: FfiConverterDouble.read(from: &buf), 
                gAngle: FfiConverterDouble.read(from: &buf), 
                intensity: FfiConverterDouble.read(from: &buf), 
                candela: FfiConverterDouble.read(from: &buf), 
                normalized: FfiConverterDouble.read(from: &buf), 
                color: FfiConverterTypeColor.read(from: &buf), 
                x: FfiConverterDouble.read(from: &buf), 
                y: FfiConverterDouble.read(from: &buf), 
                width: FfiConverterDouble.read(from: &buf), 
                height: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: HeatmapCell, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.cIndex, into: &buf)
        FfiConverterUInt32.write(value.gIndex, into: &buf)
        FfiConverterDouble.write(value.cAngle, into: &buf)
        FfiConverterDouble.write(value.gAngle, into: &buf)
        FfiConverterDouble.write(value.intensity, into: &buf)
        FfiConverterDouble.write(value.candela, into: &buf)
        FfiConverterDouble.write(value.normalized, into: &buf)
        FfiConverterTypeColor.write(value.color, into: &buf)
        FfiConverterDouble.write(value.x, into: &buf)
        FfiConverterDouble.write(value.y, into: &buf)
        FfiConverterDouble.write(value.width, into: &buf)
        FfiConverterDouble.write(value.height, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeatmapCell_lift(_ buf: RustBuffer) throws -> HeatmapCell {
    return try FfiConverterTypeHeatmapCell.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeatmapCell_lower(_ value: HeatmapCell) -> RustBuffer {
    return FfiConverterTypeHeatmapCell.lower(value)
}


public struct HeatmapDiagramData {
    public var cells: [HeatmapCell]
    public var scale: DiagramScale
    public var maxCandela: Double
    public var totalFlux: Double
    public var cAngles: [Double]
    public var gAngles: [Double]
    public var legendEntries: [LegendEntry]
    public var plotWidth: Double
    public var plotHeight: Double
    public var marginLeft: Double
    public var marginTop: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cells: [HeatmapCell], scale: DiagramScale, maxCandela: Double, totalFlux: Double, cAngles: [Double], gAngles: [Double], legendEntries: [LegendEntry], plotWidth: Double, plotHeight: Double, marginLeft: Double, marginTop: Double) {
        self.cells = cells
        self.scale = scale
        self.maxCandela = maxCandela
        self.totalFlux = totalFlux
        self.cAngles = cAngles
        self.gAngles = gAngles
        self.legendEntries = legendEntries
        self.plotWidth = plotWidth
        self.plotHeight = plotHeight
        self.marginLeft = marginLeft
        self.marginTop = marginTop
    }
}



extension HeatmapDiagramData: Equatable, Hashable {
    public static func ==(lhs: HeatmapDiagramData, rhs: HeatmapDiagramData) -> Bool {
        if lhs.cells != rhs.cells {
            return false
        }
        if lhs.scale != rhs.scale {
            return false
        }
        if lhs.maxCandela != rhs.maxCandela {
            return false
        }
        if lhs.totalFlux != rhs.totalFlux {
            return false
        }
        if lhs.cAngles != rhs.cAngles {
            return false
        }
        if lhs.gAngles != rhs.gAngles {
            return false
        }
        if lhs.legendEntries != rhs.legendEntries {
            return false
        }
        if lhs.plotWidth != rhs.plotWidth {
            return false
        }
        if lhs.plotHeight != rhs.plotHeight {
            return false
        }
        if lhs.marginLeft != rhs.marginLeft {
            return false
        }
        if lhs.marginTop != rhs.marginTop {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cells)
        hasher.combine(scale)
        hasher.combine(maxCandela)
        hasher.combine(totalFlux)
        hasher.combine(cAngles)
        hasher.combine(gAngles)
        hasher.combine(legendEntries)
        hasher.combine(plotWidth)
        hasher.combine(plotHeight)
        hasher.combine(marginLeft)
        hasher.combine(marginTop)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHeatmapDiagramData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HeatmapDiagramData {
        return
            try HeatmapDiagramData(
                cells: FfiConverterSequenceTypeHeatmapCell.read(from: &buf), 
                scale: FfiConverterTypeDiagramScale.read(from: &buf), 
                maxCandela: FfiConverterDouble.read(from: &buf), 
                totalFlux: FfiConverterDouble.read(from: &buf), 
                cAngles: FfiConverterSequenceDouble.read(from: &buf), 
                gAngles: FfiConverterSequenceDouble.read(from: &buf), 
                legendEntries: FfiConverterSequenceTypeLegendEntry.read(from: &buf), 
                plotWidth: FfiConverterDouble.read(from: &buf), 
                plotHeight: FfiConverterDouble.read(from: &buf), 
                marginLeft: FfiConverterDouble.read(from: &buf), 
                marginTop: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: HeatmapDiagramData, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeHeatmapCell.write(value.cells, into: &buf)
        FfiConverterTypeDiagramScale.write(value.scale, into: &buf)
        FfiConverterDouble.write(value.maxCandela, into: &buf)
        FfiConverterDouble.write(value.totalFlux, into: &buf)
        FfiConverterSequenceDouble.write(value.cAngles, into: &buf)
        FfiConverterSequenceDouble.write(value.gAngles, into: &buf)
        FfiConverterSequenceTypeLegendEntry.write(value.legendEntries, into: &buf)
        FfiConverterDouble.write(value.plotWidth, into: &buf)
        FfiConverterDouble.write(value.plotHeight, into: &buf)
        FfiConverterDouble.write(value.marginLeft, into: &buf)
        FfiConverterDouble.write(value.marginTop, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeatmapDiagramData_lift(_ buf: RustBuffer) throws -> HeatmapDiagramData {
    return try FfiConverterTypeHeatmapDiagramData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeatmapDiagramData_lower(_ value: HeatmapDiagramData) -> RustBuffer {
    return FfiConverterTypeHeatmapDiagramData.lower(value)
}


public struct LampSet {
    public var numLamps: Int32
    public var lampType: String
    public var totalLuminousFlux: Double
    public var colorAppearance: String
    public var colorRenderingGroup: String
    public var wattageWithBallast: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(numLamps: Int32, lampType: String, totalLuminousFlux: Double, colorAppearance: String, colorRenderingGroup: String, wattageWithBallast: Double) {
        self.numLamps = numLamps
        self.lampType = lampType
        self.totalLuminousFlux = totalLuminousFlux
        self.colorAppearance = colorAppearance
        self.colorRenderingGroup = colorRenderingGroup
        self.wattageWithBallast = wattageWithBallast
    }
}



extension LampSet: Equatable, Hashable {
    public static func ==(lhs: LampSet, rhs: LampSet) -> Bool {
        if lhs.numLamps != rhs.numLamps {
            return false
        }
        if lhs.lampType != rhs.lampType {
            return false
        }
        if lhs.totalLuminousFlux != rhs.totalLuminousFlux {
            return false
        }
        if lhs.colorAppearance != rhs.colorAppearance {
            return false
        }
        if lhs.colorRenderingGroup != rhs.colorRenderingGroup {
            return false
        }
        if lhs.wattageWithBallast != rhs.wattageWithBallast {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numLamps)
        hasher.combine(lampType)
        hasher.combine(totalLuminousFlux)
        hasher.combine(colorAppearance)
        hasher.combine(colorRenderingGroup)
        hasher.combine(wattageWithBallast)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLampSet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LampSet {
        return
            try LampSet(
                numLamps: FfiConverterInt32.read(from: &buf), 
                lampType: FfiConverterString.read(from: &buf), 
                totalLuminousFlux: FfiConverterDouble.read(from: &buf), 
                colorAppearance: FfiConverterString.read(from: &buf), 
                colorRenderingGroup: FfiConverterString.read(from: &buf), 
                wattageWithBallast: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: LampSet, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.numLamps, into: &buf)
        FfiConverterString.write(value.lampType, into: &buf)
        FfiConverterDouble.write(value.totalLuminousFlux, into: &buf)
        FfiConverterString.write(value.colorAppearance, into: &buf)
        FfiConverterString.write(value.colorRenderingGroup, into: &buf)
        FfiConverterDouble.write(value.wattageWithBallast, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLampSet_lift(_ buf: RustBuffer) throws -> LampSet {
    return try FfiConverterTypeLampSet.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLampSet_lower(_ value: LampSet) -> RustBuffer {
    return FfiConverterTypeLampSet.lower(value)
}


public struct LegendEntry {
    public var normalized: Double
    public var color: Color
    public var candela: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(normalized: Double, color: Color, candela: Double) {
        self.normalized = normalized
        self.color = color
        self.candela = candela
    }
}



extension LegendEntry: Equatable, Hashable {
    public static func ==(lhs: LegendEntry, rhs: LegendEntry) -> Bool {
        if lhs.normalized != rhs.normalized {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.candela != rhs.candela {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(normalized)
        hasher.combine(color)
        hasher.combine(candela)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegendEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegendEntry {
        return
            try LegendEntry(
                normalized: FfiConverterDouble.read(from: &buf), 
                color: FfiConverterTypeColor.read(from: &buf), 
                candela: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: LegendEntry, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.normalized, into: &buf)
        FfiConverterTypeColor.write(value.color, into: &buf)
        FfiConverterDouble.write(value.candela, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegendEntry_lift(_ buf: RustBuffer) throws -> LegendEntry {
    return try FfiConverterTypeLegendEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegendEntry_lower(_ value: LegendEntry) -> RustBuffer {
    return FfiConverterTypeLegendEntry.lower(value)
}


public struct Point2D {
    public var x: Double
    public var y: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(x: Double, y: Double) {
        self.x = x
        self.y = y
    }
}



extension Point2D: Equatable, Hashable {
    public static func ==(lhs: Point2D, rhs: Point2D) -> Bool {
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x)
        hasher.combine(y)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePoint2D: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Point2D {
        return
            try Point2D(
                x: FfiConverterDouble.read(from: &buf), 
                y: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Point2D, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.x, into: &buf)
        FfiConverterDouble.write(value.y, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoint2D_lift(_ buf: RustBuffer) throws -> Point2D {
    return try FfiConverterTypePoint2D.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoint2D_lower(_ value: Point2D) -> RustBuffer {
    return FfiConverterTypePoint2D.lower(value)
}


public struct PolarCurve {
    public var points: [PolarPoint]
    public var cAngle: Double
    public var label: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(points: [PolarPoint], cAngle: Double, label: String) {
        self.points = points
        self.cAngle = cAngle
        self.label = label
    }
}



extension PolarCurve: Equatable, Hashable {
    public static func ==(lhs: PolarCurve, rhs: PolarCurve) -> Bool {
        if lhs.points != rhs.points {
            return false
        }
        if lhs.cAngle != rhs.cAngle {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(points)
        hasher.combine(cAngle)
        hasher.combine(label)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePolarCurve: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PolarCurve {
        return
            try PolarCurve(
                points: FfiConverterSequenceTypePolarPoint.read(from: &buf), 
                cAngle: FfiConverterDouble.read(from: &buf), 
                label: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PolarCurve, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePolarPoint.write(value.points, into: &buf)
        FfiConverterDouble.write(value.cAngle, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolarCurve_lift(_ buf: RustBuffer) throws -> PolarCurve {
    return try FfiConverterTypePolarCurve.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolarCurve_lower(_ value: PolarCurve) -> RustBuffer {
    return FfiConverterTypePolarCurve.lower(value)
}


public struct PolarDiagramData {
    public var c0C180Curve: PolarCurve
    public var c90C270Curve: PolarCurve
    public var scale: DiagramScale
    public var symmetry: Symmetry
    public var showC90C270: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(c0C180Curve: PolarCurve, c90C270Curve: PolarCurve, scale: DiagramScale, symmetry: Symmetry, showC90C270: Bool) {
        self.c0C180Curve = c0C180Curve
        self.c90C270Curve = c90C270Curve
        self.scale = scale
        self.symmetry = symmetry
        self.showC90C270 = showC90C270
    }
}



extension PolarDiagramData: Equatable, Hashable {
    public static func ==(lhs: PolarDiagramData, rhs: PolarDiagramData) -> Bool {
        if lhs.c0C180Curve != rhs.c0C180Curve {
            return false
        }
        if lhs.c90C270Curve != rhs.c90C270Curve {
            return false
        }
        if lhs.scale != rhs.scale {
            return false
        }
        if lhs.symmetry != rhs.symmetry {
            return false
        }
        if lhs.showC90C270 != rhs.showC90C270 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(c0C180Curve)
        hasher.combine(c90C270Curve)
        hasher.combine(scale)
        hasher.combine(symmetry)
        hasher.combine(showC90C270)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePolarDiagramData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PolarDiagramData {
        return
            try PolarDiagramData(
                c0C180Curve: FfiConverterTypePolarCurve.read(from: &buf), 
                c90C270Curve: FfiConverterTypePolarCurve.read(from: &buf), 
                scale: FfiConverterTypeDiagramScale.read(from: &buf), 
                symmetry: FfiConverterTypeSymmetry.read(from: &buf), 
                showC90C270: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: PolarDiagramData, into buf: inout [UInt8]) {
        FfiConverterTypePolarCurve.write(value.c0C180Curve, into: &buf)
        FfiConverterTypePolarCurve.write(value.c90C270Curve, into: &buf)
        FfiConverterTypeDiagramScale.write(value.scale, into: &buf)
        FfiConverterTypeSymmetry.write(value.symmetry, into: &buf)
        FfiConverterBool.write(value.showC90C270, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolarDiagramData_lift(_ buf: RustBuffer) throws -> PolarDiagramData {
    return try FfiConverterTypePolarDiagramData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolarDiagramData_lower(_ value: PolarDiagramData) -> RustBuffer {
    return FfiConverterTypePolarDiagramData.lower(value)
}


public struct PolarPoint {
    public var x: Double
    public var y: Double
    public var gamma: Double
    public var intensity: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(x: Double, y: Double, gamma: Double, intensity: Double) {
        self.x = x
        self.y = y
        self.gamma = gamma
        self.intensity = intensity
    }
}



extension PolarPoint: Equatable, Hashable {
    public static func ==(lhs: PolarPoint, rhs: PolarPoint) -> Bool {
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        if lhs.gamma != rhs.gamma {
            return false
        }
        if lhs.intensity != rhs.intensity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x)
        hasher.combine(y)
        hasher.combine(gamma)
        hasher.combine(intensity)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePolarPoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PolarPoint {
        return
            try PolarPoint(
                x: FfiConverterDouble.read(from: &buf), 
                y: FfiConverterDouble.read(from: &buf), 
                gamma: FfiConverterDouble.read(from: &buf), 
                intensity: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: PolarPoint, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.x, into: &buf)
        FfiConverterDouble.write(value.y, into: &buf)
        FfiConverterDouble.write(value.gamma, into: &buf)
        FfiConverterDouble.write(value.intensity, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolarPoint_lift(_ buf: RustBuffer) throws -> PolarPoint {
    return try FfiConverterTypePolarPoint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolarPoint_lower(_ value: PolarPoint) -> RustBuffer {
    return FfiConverterTypePolarPoint.lower(value)
}


/**
 * Zone lumens data for BUG rating
 */
public struct ZoneLumens {
    public var bl: Double
    public var bm: Double
    public var bh: Double
    public var bvh: Double
    public var fl: Double
    public var fm: Double
    public var fh: Double
    public var fvh: Double
    public var ul: Double
    public var uh: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bl: Double, bm: Double, bh: Double, bvh: Double, fl: Double, fm: Double, fh: Double, fvh: Double, ul: Double, uh: Double) {
        self.bl = bl
        self.bm = bm
        self.bh = bh
        self.bvh = bvh
        self.fl = fl
        self.fm = fm
        self.fh = fh
        self.fvh = fvh
        self.ul = ul
        self.uh = uh
    }
}



extension ZoneLumens: Equatable, Hashable {
    public static func ==(lhs: ZoneLumens, rhs: ZoneLumens) -> Bool {
        if lhs.bl != rhs.bl {
            return false
        }
        if lhs.bm != rhs.bm {
            return false
        }
        if lhs.bh != rhs.bh {
            return false
        }
        if lhs.bvh != rhs.bvh {
            return false
        }
        if lhs.fl != rhs.fl {
            return false
        }
        if lhs.fm != rhs.fm {
            return false
        }
        if lhs.fh != rhs.fh {
            return false
        }
        if lhs.fvh != rhs.fvh {
            return false
        }
        if lhs.ul != rhs.ul {
            return false
        }
        if lhs.uh != rhs.uh {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bl)
        hasher.combine(bm)
        hasher.combine(bh)
        hasher.combine(bvh)
        hasher.combine(fl)
        hasher.combine(fm)
        hasher.combine(fh)
        hasher.combine(fvh)
        hasher.combine(ul)
        hasher.combine(uh)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeZoneLumens: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZoneLumens {
        return
            try ZoneLumens(
                bl: FfiConverterDouble.read(from: &buf), 
                bm: FfiConverterDouble.read(from: &buf), 
                bh: FfiConverterDouble.read(from: &buf), 
                bvh: FfiConverterDouble.read(from: &buf), 
                fl: FfiConverterDouble.read(from: &buf), 
                fm: FfiConverterDouble.read(from: &buf), 
                fh: FfiConverterDouble.read(from: &buf), 
                fvh: FfiConverterDouble.read(from: &buf), 
                ul: FfiConverterDouble.read(from: &buf), 
                uh: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: ZoneLumens, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.bl, into: &buf)
        FfiConverterDouble.write(value.bm, into: &buf)
        FfiConverterDouble.write(value.bh, into: &buf)
        FfiConverterDouble.write(value.bvh, into: &buf)
        FfiConverterDouble.write(value.fl, into: &buf)
        FfiConverterDouble.write(value.fm, into: &buf)
        FfiConverterDouble.write(value.fh, into: &buf)
        FfiConverterDouble.write(value.fvh, into: &buf)
        FfiConverterDouble.write(value.ul, into: &buf)
        FfiConverterDouble.write(value.uh, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeZoneLumens_lift(_ buf: RustBuffer) throws -> ZoneLumens {
    return try FfiConverterTypeZoneLumens.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeZoneLumens_lower(_ value: ZoneLumens) -> RustBuffer {
    return FfiConverterTypeZoneLumens.lower(value)
}


public enum EulumdatError {

    
    
    case ParseError(String
    )
    case ValidationError(String
    )
    case IoError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEulumdatError: FfiConverterRustBuffer {
    typealias SwiftType = EulumdatError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EulumdatError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ParseError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .ValidationError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .IoError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EulumdatError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ParseError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ValidationError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .IoError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension EulumdatError: Equatable, Hashable {}

extension EulumdatError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SvgThemeType {
    
    case light
    case dark
    case cssVariables
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSvgThemeType: FfiConverterRustBuffer {
    typealias SwiftType = SvgThemeType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SvgThemeType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .light
        
        case 2: return .dark
        
        case 3: return .cssVariables
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SvgThemeType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .light:
            writeInt(&buf, Int32(1))
        
        
        case .dark:
            writeInt(&buf, Int32(2))
        
        
        case .cssVariables:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSvgThemeType_lift(_ buf: RustBuffer) throws -> SvgThemeType {
    return try FfiConverterTypeSvgThemeType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSvgThemeType_lower(_ value: SvgThemeType) -> RustBuffer {
    return FfiConverterTypeSvgThemeType.lower(value)
}



extension SvgThemeType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Symmetry {
    
    case none
    case verticalAxis
    case planeC0c180
    case planeC90c270
    case bothPlanes
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSymmetry: FfiConverterRustBuffer {
    typealias SwiftType = Symmetry

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Symmetry {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .verticalAxis
        
        case 3: return .planeC0c180
        
        case 4: return .planeC90c270
        
        case 5: return .bothPlanes
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Symmetry, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case .verticalAxis:
            writeInt(&buf, Int32(2))
        
        
        case .planeC0c180:
            writeInt(&buf, Int32(3))
        
        
        case .planeC90c270:
            writeInt(&buf, Int32(4))
        
        
        case .bothPlanes:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSymmetry_lift(_ buf: RustBuffer) throws -> Symmetry {
    return try FfiConverterTypeSymmetry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSymmetry_lower(_ value: Symmetry) -> RustBuffer {
    return FfiConverterTypeSymmetry.lower(value)
}



extension Symmetry: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TypeIndicator {
    
    case pointSourceSymmetric
    case linear
    case pointSourceOther
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTypeIndicator: FfiConverterRustBuffer {
    typealias SwiftType = TypeIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypeIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pointSourceSymmetric
        
        case 2: return .linear
        
        case 3: return .pointSourceOther
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TypeIndicator, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pointSourceSymmetric:
            writeInt(&buf, Int32(1))
        
        
        case .linear:
            writeInt(&buf, Int32(2))
        
        
        case .pointSourceOther:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTypeIndicator_lift(_ buf: RustBuffer) throws -> TypeIndicator {
    return try FfiConverterTypeTypeIndicator.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTypeIndicator_lower(_ value: TypeIndicator) -> RustBuffer {
    return FfiConverterTypeTypeIndicator.lower(value)
}



extension TypeIndicator: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceDouble: FfiConverterRustBuffer {
    typealias SwiftType = [Double]

    public static func write(_ value: [Double], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterDouble.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Double] {
        let len: Int32 = try readInt(&buf)
        var seq = [Double]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterDouble.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeButterflyWing: FfiConverterRustBuffer {
    typealias SwiftType = [ButterflyWing]

    public static func write(_ value: [ButterflyWing], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeButterflyWing.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ButterflyWing] {
        let len: Int32 = try readInt(&buf)
        var seq = [ButterflyWing]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeButterflyWing.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCPlaneDirection: FfiConverterRustBuffer {
    typealias SwiftType = [CPlaneDirection]

    public static func write(_ value: [CPlaneDirection], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCPlaneDirection.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CPlaneDirection] {
        let len: Int32 = try readInt(&buf)
        var seq = [CPlaneDirection]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCPlaneDirection.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCartesianCurve: FfiConverterRustBuffer {
    typealias SwiftType = [CartesianCurve]

    public static func write(_ value: [CartesianCurve], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCartesianCurve.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CartesianCurve] {
        let len: Int32 = try readInt(&buf)
        var seq = [CartesianCurve]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCartesianCurve.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCartesianPoint: FfiConverterRustBuffer {
    typealias SwiftType = [CartesianPoint]

    public static func write(_ value: [CartesianPoint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCartesianPoint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CartesianPoint] {
        let len: Int32 = try readInt(&buf)
        var seq = [CartesianPoint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCartesianPoint.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHeatmapCell: FfiConverterRustBuffer {
    typealias SwiftType = [HeatmapCell]

    public static func write(_ value: [HeatmapCell], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHeatmapCell.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HeatmapCell] {
        let len: Int32 = try readInt(&buf)
        var seq = [HeatmapCell]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHeatmapCell.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLampSet: FfiConverterRustBuffer {
    typealias SwiftType = [LampSet]

    public static func write(_ value: [LampSet], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLampSet.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LampSet] {
        let len: Int32 = try readInt(&buf)
        var seq = [LampSet]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLampSet.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLegendEntry: FfiConverterRustBuffer {
    typealias SwiftType = [LegendEntry]

    public static func write(_ value: [LegendEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLegendEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LegendEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [LegendEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLegendEntry.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePoint2D: FfiConverterRustBuffer {
    typealias SwiftType = [Point2D]

    public static func write(_ value: [Point2D], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePoint2D.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Point2D] {
        let len: Int32 = try readInt(&buf)
        var seq = [Point2D]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePoint2D.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePolarPoint: FfiConverterRustBuffer {
    typealias SwiftType = [PolarPoint]

    public static func write(_ value: [PolarPoint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePolarPoint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PolarPoint] {
        let len: Int32 = try readInt(&buf)
        var seq = [PolarPoint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePolarPoint.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceDouble: FfiConverterRustBuffer {
    typealias SwiftType = [[Double]]

    public static func write(_ value: [[Double]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceDouble.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[Double]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[Double]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceDouble.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceTypePoint2D: FfiConverterRustBuffer {
    typealias SwiftType = [[Point2D]]

    public static func write(_ value: [[Point2D]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceTypePoint2D.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[Point2D]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[Point2D]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceTypePoint2D.read(from: &buf))
        }
        return seq
    }
}
/**
 * Calculate BUG rating from Eulumdat data
 */
public func calculateBugRating(ldt: Eulumdat) -> BugRatingData {
    return try!  FfiConverterTypeBugRatingData.lift(try! rustCall() {
    uniffi_eulumdat_ffi_fn_func_calculate_bug_rating(
        FfiConverterTypeEulumdat.lower(ldt),$0
    )
})
}
/**
 * Generate BUG diagram data
 */
public func generateBugDiagram(ldt: Eulumdat) -> BugDiagramData {
    return try!  FfiConverterTypeBugDiagramData.lift(try! rustCall() {
    uniffi_eulumdat_ffi_fn_func_generate_bug_diagram(
        FfiConverterTypeEulumdat.lower(ldt),$0
    )
})
}
/**
 * Generate BUG rating diagram as SVG (TM-15-11 view)
 */
public func generateBugSvg(ldt: Eulumdat, width: Double, height: Double, theme: SvgThemeType) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_eulumdat_ffi_fn_func_generate_bug_svg(
        FfiConverterTypeEulumdat.lower(ldt),
        FfiConverterDouble.lower(width),
        FfiConverterDouble.lower(height),
        FfiConverterTypeSvgThemeType.lower(theme),$0
    )
})
}
/**
 * Generate butterfly diagram data
 */
public func generateButterflyDiagram(ldt: Eulumdat, width: Double, height: Double, tiltDegrees: Double) -> ButterflyDiagramData {
    return try!  FfiConverterTypeButterflyDiagramData.lift(try! rustCall() {
    uniffi_eulumdat_ffi_fn_func_generate_butterfly_diagram(
        FfiConverterTypeEulumdat.lower(ldt),
        FfiConverterDouble.lower(width),
        FfiConverterDouble.lower(height),
        FfiConverterDouble.lower(tiltDegrees),$0
    )
})
}
/**
 * Generate butterfly diagram as SVG string
 */
public func generateButterflySvg(ldt: Eulumdat, width: Double, height: Double, tiltDegrees: Double, theme: SvgThemeType) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_eulumdat_ffi_fn_func_generate_butterfly_svg(
        FfiConverterTypeEulumdat.lower(ldt),
        FfiConverterDouble.lower(width),
        FfiConverterDouble.lower(height),
        FfiConverterDouble.lower(tiltDegrees),
        FfiConverterTypeSvgThemeType.lower(theme),$0
    )
})
}
/**
 * Generate cartesian diagram data
 */
public func generateCartesianDiagram(ldt: Eulumdat, width: Double, height: Double, maxCurves: UInt32) -> CartesianDiagramData {
    return try!  FfiConverterTypeCartesianDiagramData.lift(try! rustCall() {
    uniffi_eulumdat_ffi_fn_func_generate_cartesian_diagram(
        FfiConverterTypeEulumdat.lower(ldt),
        FfiConverterDouble.lower(width),
        FfiConverterDouble.lower(height),
        FfiConverterUInt32.lower(maxCurves),$0
    )
})
}
/**
 * Generate cartesian diagram as SVG string
 */
public func generateCartesianSvg(ldt: Eulumdat, width: Double, height: Double, maxCurves: UInt32, theme: SvgThemeType) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_eulumdat_ffi_fn_func_generate_cartesian_svg(
        FfiConverterTypeEulumdat.lower(ldt),
        FfiConverterDouble.lower(width),
        FfiConverterDouble.lower(height),
        FfiConverterUInt32.lower(maxCurves),
        FfiConverterTypeSvgThemeType.lower(theme),$0
    )
})
}
/**
 * Generate heatmap diagram data
 */
public func generateHeatmapDiagram(ldt: Eulumdat, width: Double, height: Double) -> HeatmapDiagramData {
    return try!  FfiConverterTypeHeatmapDiagramData.lift(try! rustCall() {
    uniffi_eulumdat_ffi_fn_func_generate_heatmap_diagram(
        FfiConverterTypeEulumdat.lower(ldt),
        FfiConverterDouble.lower(width),
        FfiConverterDouble.lower(height),$0
    )
})
}
/**
 * Generate heatmap diagram as SVG string
 */
public func generateHeatmapSvg(ldt: Eulumdat, width: Double, height: Double, theme: SvgThemeType) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_eulumdat_ffi_fn_func_generate_heatmap_svg(
        FfiConverterTypeEulumdat.lower(ldt),
        FfiConverterDouble.lower(width),
        FfiConverterDouble.lower(height),
        FfiConverterTypeSvgThemeType.lower(theme),$0
    )
})
}
/**
 * Generate LCS diagram as SVG (TM-15-07 view)
 */
public func generateLcsSvg(ldt: Eulumdat, width: Double, height: Double, theme: SvgThemeType) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_eulumdat_ffi_fn_func_generate_lcs_svg(
        FfiConverterTypeEulumdat.lower(ldt),
        FfiConverterDouble.lower(width),
        FfiConverterDouble.lower(height),
        FfiConverterTypeSvgThemeType.lower(theme),$0
    )
})
}
/**
 * Generate polar diagram data
 */
public func generatePolarDiagram(ldt: Eulumdat) -> PolarDiagramData {
    return try!  FfiConverterTypePolarDiagramData.lift(try! rustCall() {
    uniffi_eulumdat_ffi_fn_func_generate_polar_diagram(
        FfiConverterTypeEulumdat.lower(ldt),$0
    )
})
}
/**
 * Generate polar diagram as SVG string
 */
public func generatePolarSvg(ldt: Eulumdat, width: Double, height: Double, theme: SvgThemeType) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_eulumdat_ffi_fn_func_generate_polar_svg(
        FfiConverterTypeEulumdat.lower(ldt),
        FfiConverterDouble.lower(width),
        FfiConverterDouble.lower(height),
        FfiConverterTypeSvgThemeType.lower(theme),$0
    )
})
}
/**
 * Parse LDT content and return an Eulumdat object
 */
public func parseLdt(content: String)throws  -> Eulumdat {
    return try  FfiConverterTypeEulumdat.lift(try rustCallWithError(FfiConverterTypeEulumdatError.lift) {
    uniffi_eulumdat_ffi_fn_func_parse_ldt(
        FfiConverterString.lower(content),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_eulumdat_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_calculate_bug_rating() != 58767) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_generate_bug_diagram() != 34423) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_generate_bug_svg() != 63921) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_generate_butterfly_diagram() != 60884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_generate_butterfly_svg() != 24398) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_generate_cartesian_diagram() != 14573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_generate_cartesian_svg() != 18468) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_generate_heatmap_diagram() != 2153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_generate_heatmap_svg() != 53812) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_generate_lcs_svg() != 35133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_generate_polar_diagram() != 46629) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_generate_polar_svg() != 39828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_eulumdat_ffi_checksum_func_parse_ldt() != 27501) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all