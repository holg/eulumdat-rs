// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi.eulumdat_ffi

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.ConcurrentHashMap

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

/**
 * @suppress
 */
@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField var capacity: Long = 0
    @JvmField var len: Long = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

   internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) = uniffiRustCall() { status ->
            // Note: need to convert the size to a `Long` value to make this work with JVM.
            UniffiLib.INSTANCE.ffi_eulumdat_ffi_rustbuffer_alloc(size.toLong(), status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: ULong, len: ULong, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_eulumdat_ffi_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 *
 * @suppress
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setLong(0, value.capacity)
        pointer.setLong(8, value.len)
        pointer.setPointer(16, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getLong(0))
        value.writeField("len", pointer.getLong(8))
        value.writeField("data", pointer.getLong(16))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
internal open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
/**
 * The FfiConverter interface handles converter types to and from the FFI
 *
 * All implementing objects should be public to support external types.  When a
 * type is external we need to import it's FfiConverter.
 *
 * @suppress
 */
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

/**
 * FfiConverter that uses `RustBuffer` as the FfiType
 *
 * @suppress
 */
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == UNIFFI_CALL_SUCCESS
    }

    fun isError(): Boolean {
        return code == UNIFFI_CALL_ERROR
    }

    fun isPanic(): Boolean {
        return code == UNIFFI_CALL_UNEXPECTED_ERROR
    }

    companion object {
        fun create(code: Byte, errorBuf: RustBuffer.ByValue): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(message: String) : kotlin.Exception(message)

/**
 * Each top-level error class has a companion object that can lift the error from the call status's rust buffer
 *
 * @suppress
 */
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: kotlin.Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus()
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: kotlin.Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

/**
 * UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
 *
 * @suppress
 */
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)
}

internal inline fun<T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(e.toString())
    }
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(e.toString())
        }
    }
}
// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<Long, T>()
    private val counter = java.util.concurrent.atomic.AtomicLong(0)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(1)
        map.put(handle, obj)
        return handle
    }

    // Get an object from the handle map
    fun get(handle: Long): T {
        return map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")
    }

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T {
        return map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "eulumdat_ffi"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(`data`: Long,`pollResult`: Byte,)
}
internal interface UniffiForeignFutureFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFuture(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureFree? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureFree? = null,
    ): UniffiForeignFuture(`handle`,`free`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFuture) {
        `handle` = other.`handle`
        `free` = other.`free`
    }

}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructPointer(
    @JvmField internal var `returnValue`: Pointer = Pointer.NULL,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Pointer = Pointer.NULL,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructPointer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructPointer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompletePointer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructPointer.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructRustBuffer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructRustBuffer.UniffiByValue,)
}
@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureStructVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructVoid(`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructVoid) {
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructVoid.UniffiByValue,)
}
















































































































// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            loadIndirect<UniffiLib>(componentName = "eulumdat_ffi")
            .also { lib: UniffiLib ->
                uniffiCheckContractApiVersion(lib)
                uniffiCheckApiChecksums(lib)
                }
        }
        
    }

    fun uniffi_eulumdat_ffi_fn_func_batch_convert_contents(`files`: RustBuffer.ByValue,`format`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_batch_convert_to_ies(`files`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_calculate_bug_rating(`ldt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_convert_ldt_to_ies(`ldtContent`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_convert_ldt_to_ldt(`ldtContent`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_export_ies(`ldt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_export_ldt(`ldt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_bug_diagram(`ldt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_bug_svg(`ldt`: RustBuffer.ByValue,`width`: Double,`height`: Double,`theme`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_butterfly_diagram(`ldt`: RustBuffer.ByValue,`width`: Double,`height`: Double,`tiltDegrees`: Double,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_butterfly_svg(`ldt`: RustBuffer.ByValue,`width`: Double,`height`: Double,`tiltDegrees`: Double,`theme`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_cartesian_diagram(`ldt`: RustBuffer.ByValue,`width`: Double,`height`: Double,`maxCurves`: Int,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_cartesian_svg(`ldt`: RustBuffer.ByValue,`width`: Double,`height`: Double,`maxCurves`: Int,`theme`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_complication_svg(`ldt`: RustBuffer.ByValue,`size`: Int,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_heatmap_diagram(`ldt`: RustBuffer.ByValue,`width`: Double,`height`: Double,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_heatmap_svg(`ldt`: RustBuffer.ByValue,`width`: Double,`height`: Double,`theme`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_lcs_svg(`ldt`: RustBuffer.ByValue,`width`: Double,`height`: Double,`theme`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_photos_face_svg(`ldt`: RustBuffer.ByValue,`width`: Int,`height`: Int,`style`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_polar_diagram(`ldt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_polar_svg(`ldt`: RustBuffer.ByValue,`width`: Double,`height`: Double,`theme`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_watch_face_svg(`ldt`: RustBuffer.ByValue,`size`: Int,`style`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_generate_watch_face_svg_custom(`ldt`: RustBuffer.ByValue,`size`: Int,`style`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_get_validation_errors(`ldt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_parse_ies(`content`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_parse_ldt(`content`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_validate_ldt(`ldt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_eulumdat_ffi_fn_func_validate_ldt_strict(`ldt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun ffi_eulumdat_ffi_rustbuffer_alloc(`size`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_eulumdat_ffi_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_eulumdat_ffi_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun ffi_eulumdat_ffi_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_eulumdat_ffi_rust_future_poll_u8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_u8(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_u8(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_u8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun ffi_eulumdat_ffi_rust_future_poll_i8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_i8(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_i8(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_i8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun ffi_eulumdat_ffi_rust_future_poll_u16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_u16(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_u16(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_u16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Short
    fun ffi_eulumdat_ffi_rust_future_poll_i16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_i16(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_i16(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_i16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Short
    fun ffi_eulumdat_ffi_rust_future_poll_u32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_u32(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_u32(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_u32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun ffi_eulumdat_ffi_rust_future_poll_i32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_i32(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_i32(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_i32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun ffi_eulumdat_ffi_rust_future_poll_u64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_u64(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_u64(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_u64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun ffi_eulumdat_ffi_rust_future_poll_i64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_i64(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_i64(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_i64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun ffi_eulumdat_ffi_rust_future_poll_f32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_f32(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_f32(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_f32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Float
    fun ffi_eulumdat_ffi_rust_future_poll_f64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_f64(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_f64(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_f64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Double
    fun ffi_eulumdat_ffi_rust_future_poll_pointer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_pointer(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_pointer(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_pointer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun ffi_eulumdat_ffi_rust_future_poll_rust_buffer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_rust_buffer(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_rust_buffer(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_rust_buffer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_eulumdat_ffi_rust_future_poll_void(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_cancel_void(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_free_void(`handle`: Long,
    ): Unit
    fun ffi_eulumdat_ffi_rust_future_complete_void(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_eulumdat_ffi_checksum_func_batch_convert_contents(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_batch_convert_to_ies(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_calculate_bug_rating(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_convert_ldt_to_ies(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_convert_ldt_to_ldt(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_export_ies(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_export_ldt(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_bug_diagram(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_bug_svg(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_butterfly_diagram(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_butterfly_svg(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_cartesian_diagram(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_cartesian_svg(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_complication_svg(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_heatmap_diagram(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_heatmap_svg(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_lcs_svg(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_photos_face_svg(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_polar_diagram(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_polar_svg(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_watch_face_svg(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_generate_watch_face_svg_custom(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_get_validation_errors(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_parse_ies(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_parse_ldt(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_validate_ldt(
    ): Short
    fun uniffi_eulumdat_ffi_checksum_func_validate_ldt_strict(
    ): Short
    fun ffi_eulumdat_ffi_uniffi_contract_version(
    ): Int
    
}

private fun uniffiCheckContractApiVersion(lib: UniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_eulumdat_ffi_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}

@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: UniffiLib) {
    if (lib.uniffi_eulumdat_ffi_checksum_func_batch_convert_contents() != 46496.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_batch_convert_to_ies() != 246.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_calculate_bug_rating() != 58767.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_convert_ldt_to_ies() != 51119.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_convert_ldt_to_ldt() != 22350.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_export_ies() != 11095.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_export_ldt() != 19768.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_bug_diagram() != 34423.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_bug_svg() != 63921.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_butterfly_diagram() != 60884.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_butterfly_svg() != 24398.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_cartesian_diagram() != 14573.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_cartesian_svg() != 18468.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_complication_svg() != 12814.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_heatmap_diagram() != 2153.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_heatmap_svg() != 53812.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_lcs_svg() != 35133.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_photos_face_svg() != 40674.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_polar_diagram() != 46629.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_polar_svg() != 39828.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_watch_face_svg() != 47412.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_generate_watch_face_svg_custom() != 197.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_get_validation_errors() != 28281.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_parse_ies() != 60498.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_parse_ldt() != 27501.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_validate_ldt() != 34444.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_eulumdat_ffi_checksum_func_validate_ldt_strict() != 21146.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// Async support

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            args.filterIsInstance<Disposable>()
                .forEach(Disposable::destroy)
        }
    }
}

/**
 * @suppress
 */
inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/** 
 * Used to instantiate an interface without an actual pointer, for fakes in tests, mostly.
 *
 * @suppress
 * */
object NoPointer

/**
 * @suppress
 */
public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1UL

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

/**
 * @suppress
 */
public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4UL

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

/**
 * @suppress
 */
public object FfiConverterInt: FfiConverter<Int, Int> {
    override fun lift(value: Int): Int {
        return value
    }

    override fun read(buf: ByteBuffer): Int {
        return buf.getInt()
    }

    override fun lower(value: Int): Int {
        return value
    }

    override fun allocationSize(value: Int) = 4UL

    override fun write(value: Int, buf: ByteBuffer) {
        buf.putInt(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterDouble: FfiConverter<Double, Double> {
    override fun lift(value: Double): Double {
        return value
    }

    override fun read(buf: ByteBuffer): Double {
        return buf.getDouble()
    }

    override fun lower(value: Double): Double {
        return value
    }

    override fun allocationSize(value: Double) = 8UL

    override fun write(value: Double, buf: ByteBuffer) {
        buf.putDouble(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

/**
 * @suppress
 */
public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}



/**
 * Statistics for batch conversion
 */
data class BatchConversionStats (
    var `totalFiles`: kotlin.UInt, 
    var `successful`: kotlin.UInt, 
    var `failed`: kotlin.UInt, 
    var `results`: List<ConversionResult>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBatchConversionStats: FfiConverterRustBuffer<BatchConversionStats> {
    override fun read(buf: ByteBuffer): BatchConversionStats {
        return BatchConversionStats(
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterSequenceTypeConversionResult.read(buf),
        )
    }

    override fun allocationSize(value: BatchConversionStats) = (
            FfiConverterUInt.allocationSize(value.`totalFiles`) +
            FfiConverterUInt.allocationSize(value.`successful`) +
            FfiConverterUInt.allocationSize(value.`failed`) +
            FfiConverterSequenceTypeConversionResult.allocationSize(value.`results`)
    )

    override fun write(value: BatchConversionStats, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`totalFiles`, buf)
            FfiConverterUInt.write(value.`successful`, buf)
            FfiConverterUInt.write(value.`failed`, buf)
            FfiConverterSequenceTypeConversionResult.write(value.`results`, buf)
    }
}



/**
 * Input file for batch conversion
 */
data class BatchInputFile (
    var `name`: kotlin.String, 
    var `content`: kotlin.String, 
    /**
     * Optional input format (auto-detected if None)
     */
    var `format`: InputFormat?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBatchInputFile: FfiConverterRustBuffer<BatchInputFile> {
    override fun read(buf: ByteBuffer): BatchInputFile {
        return BatchInputFile(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalTypeInputFormat.read(buf),
        )
    }

    override fun allocationSize(value: BatchInputFile) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`content`) +
            FfiConverterOptionalTypeInputFormat.allocationSize(value.`format`)
    )

    override fun write(value: BatchInputFile, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`content`, buf)
            FfiConverterOptionalTypeInputFormat.write(value.`format`, buf)
    }
}



/**
 * Output file from batch conversion
 */
data class BatchOutputFile (
    var `inputName`: kotlin.String, 
    var `outputName`: kotlin.String, 
    var `content`: kotlin.String?, 
    var `error`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBatchOutputFile: FfiConverterRustBuffer<BatchOutputFile> {
    override fun read(buf: ByteBuffer): BatchOutputFile {
        return BatchOutputFile(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: BatchOutputFile) = (
            FfiConverterString.allocationSize(value.`inputName`) +
            FfiConverterString.allocationSize(value.`outputName`) +
            FfiConverterOptionalString.allocationSize(value.`content`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: BatchOutputFile, buf: ByteBuffer) {
            FfiConverterString.write(value.`inputName`, buf)
            FfiConverterString.write(value.`outputName`, buf)
            FfiConverterOptionalString.write(value.`content`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * Complete BUG diagram data
 */
data class BugDiagramData (
    var `zones`: ZoneLumens, 
    var `rating`: BugRatingData, 
    var `totalLumens`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBugDiagramData: FfiConverterRustBuffer<BugDiagramData> {
    override fun read(buf: ByteBuffer): BugDiagramData {
        return BugDiagramData(
            FfiConverterTypeZoneLumens.read(buf),
            FfiConverterTypeBugRatingData.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: BugDiagramData) = (
            FfiConverterTypeZoneLumens.allocationSize(value.`zones`) +
            FfiConverterTypeBugRatingData.allocationSize(value.`rating`) +
            FfiConverterDouble.allocationSize(value.`totalLumens`)
    )

    override fun write(value: BugDiagramData, buf: ByteBuffer) {
            FfiConverterTypeZoneLumens.write(value.`zones`, buf)
            FfiConverterTypeBugRatingData.write(value.`rating`, buf)
            FfiConverterDouble.write(value.`totalLumens`, buf)
    }
}



/**
 * BUG rating values (0-5 scale)
 */
data class BugRatingData (
    var `b`: kotlin.UByte, 
    var `u`: kotlin.UByte, 
    var `g`: kotlin.UByte
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBugRatingData: FfiConverterRustBuffer<BugRatingData> {
    override fun read(buf: ByteBuffer): BugRatingData {
        return BugRatingData(
            FfiConverterUByte.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterUByte.read(buf),
        )
    }

    override fun allocationSize(value: BugRatingData) = (
            FfiConverterUByte.allocationSize(value.`b`) +
            FfiConverterUByte.allocationSize(value.`u`) +
            FfiConverterUByte.allocationSize(value.`g`)
    )

    override fun write(value: BugRatingData, buf: ByteBuffer) {
            FfiConverterUByte.write(value.`b`, buf)
            FfiConverterUByte.write(value.`u`, buf)
            FfiConverterUByte.write(value.`g`, buf)
    }
}



data class ButterflyDiagramData (
    var `wings`: List<ButterflyWing>, 
    var `gridCircles`: List<List<Point2D>>, 
    var `cPlaneLines`: List<CPlaneDirection>, 
    var `scale`: DiagramScale, 
    var `gAngles`: List<kotlin.Double>, 
    var `symmetry`: Symmetry
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeButterflyDiagramData: FfiConverterRustBuffer<ButterflyDiagramData> {
    override fun read(buf: ByteBuffer): ButterflyDiagramData {
        return ButterflyDiagramData(
            FfiConverterSequenceTypeButterflyWing.read(buf),
            FfiConverterSequenceSequenceTypePoint2D.read(buf),
            FfiConverterSequenceTypeCPlaneDirection.read(buf),
            FfiConverterTypeDiagramScale.read(buf),
            FfiConverterSequenceDouble.read(buf),
            FfiConverterTypeSymmetry.read(buf),
        )
    }

    override fun allocationSize(value: ButterflyDiagramData) = (
            FfiConverterSequenceTypeButterflyWing.allocationSize(value.`wings`) +
            FfiConverterSequenceSequenceTypePoint2D.allocationSize(value.`gridCircles`) +
            FfiConverterSequenceTypeCPlaneDirection.allocationSize(value.`cPlaneLines`) +
            FfiConverterTypeDiagramScale.allocationSize(value.`scale`) +
            FfiConverterSequenceDouble.allocationSize(value.`gAngles`) +
            FfiConverterTypeSymmetry.allocationSize(value.`symmetry`)
    )

    override fun write(value: ButterflyDiagramData, buf: ByteBuffer) {
            FfiConverterSequenceTypeButterflyWing.write(value.`wings`, buf)
            FfiConverterSequenceSequenceTypePoint2D.write(value.`gridCircles`, buf)
            FfiConverterSequenceTypeCPlaneDirection.write(value.`cPlaneLines`, buf)
            FfiConverterTypeDiagramScale.write(value.`scale`, buf)
            FfiConverterSequenceDouble.write(value.`gAngles`, buf)
            FfiConverterTypeSymmetry.write(value.`symmetry`, buf)
    }
}



data class ButterflyWing (
    var `cAngle`: kotlin.Double, 
    var `points`: List<Point2D>, 
    var `fillColor`: Color, 
    var `strokeColor`: Color, 
    var `svgPath`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeButterflyWing: FfiConverterRustBuffer<ButterflyWing> {
    override fun read(buf: ByteBuffer): ButterflyWing {
        return ButterflyWing(
            FfiConverterDouble.read(buf),
            FfiConverterSequenceTypePoint2D.read(buf),
            FfiConverterTypeColor.read(buf),
            FfiConverterTypeColor.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ButterflyWing) = (
            FfiConverterDouble.allocationSize(value.`cAngle`) +
            FfiConverterSequenceTypePoint2D.allocationSize(value.`points`) +
            FfiConverterTypeColor.allocationSize(value.`fillColor`) +
            FfiConverterTypeColor.allocationSize(value.`strokeColor`) +
            FfiConverterString.allocationSize(value.`svgPath`)
    )

    override fun write(value: ButterflyWing, buf: ByteBuffer) {
            FfiConverterDouble.write(value.`cAngle`, buf)
            FfiConverterSequenceTypePoint2D.write(value.`points`, buf)
            FfiConverterTypeColor.write(value.`fillColor`, buf)
            FfiConverterTypeColor.write(value.`strokeColor`, buf)
            FfiConverterString.write(value.`svgPath`, buf)
    }
}



data class CPlaneDirection (
    var `angle`: kotlin.Double, 
    var `start`: Point2D, 
    var `endPoint`: Point2D
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCPlaneDirection: FfiConverterRustBuffer<CPlaneDirection> {
    override fun read(buf: ByteBuffer): CPlaneDirection {
        return CPlaneDirection(
            FfiConverterDouble.read(buf),
            FfiConverterTypePoint2D.read(buf),
            FfiConverterTypePoint2D.read(buf),
        )
    }

    override fun allocationSize(value: CPlaneDirection) = (
            FfiConverterDouble.allocationSize(value.`angle`) +
            FfiConverterTypePoint2D.allocationSize(value.`start`) +
            FfiConverterTypePoint2D.allocationSize(value.`endPoint`)
    )

    override fun write(value: CPlaneDirection, buf: ByteBuffer) {
            FfiConverterDouble.write(value.`angle`, buf)
            FfiConverterTypePoint2D.write(value.`start`, buf)
            FfiConverterTypePoint2D.write(value.`endPoint`, buf)
    }
}



data class CartesianCurve (
    var `points`: List<CartesianPoint>, 
    var `cAngle`: kotlin.Double, 
    var `color`: Color, 
    var `label`: kotlin.String, 
    var `svgPath`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCartesianCurve: FfiConverterRustBuffer<CartesianCurve> {
    override fun read(buf: ByteBuffer): CartesianCurve {
        return CartesianCurve(
            FfiConverterSequenceTypeCartesianPoint.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterTypeColor.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: CartesianCurve) = (
            FfiConverterSequenceTypeCartesianPoint.allocationSize(value.`points`) +
            FfiConverterDouble.allocationSize(value.`cAngle`) +
            FfiConverterTypeColor.allocationSize(value.`color`) +
            FfiConverterString.allocationSize(value.`label`) +
            FfiConverterString.allocationSize(value.`svgPath`)
    )

    override fun write(value: CartesianCurve, buf: ByteBuffer) {
            FfiConverterSequenceTypeCartesianPoint.write(value.`points`, buf)
            FfiConverterDouble.write(value.`cAngle`, buf)
            FfiConverterTypeColor.write(value.`color`, buf)
            FfiConverterString.write(value.`label`, buf)
            FfiConverterString.write(value.`svgPath`, buf)
    }
}



data class CartesianDiagramData (
    var `curves`: List<CartesianCurve>, 
    var `xTicks`: List<kotlin.Double>, 
    var `yTicks`: List<kotlin.Double>, 
    var `scale`: DiagramScale, 
    var `maxGamma`: kotlin.Double, 
    var `plotWidth`: kotlin.Double, 
    var `plotHeight`: kotlin.Double, 
    var `marginLeft`: kotlin.Double, 
    var `marginTop`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCartesianDiagramData: FfiConverterRustBuffer<CartesianDiagramData> {
    override fun read(buf: ByteBuffer): CartesianDiagramData {
        return CartesianDiagramData(
            FfiConverterSequenceTypeCartesianCurve.read(buf),
            FfiConverterSequenceDouble.read(buf),
            FfiConverterSequenceDouble.read(buf),
            FfiConverterTypeDiagramScale.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: CartesianDiagramData) = (
            FfiConverterSequenceTypeCartesianCurve.allocationSize(value.`curves`) +
            FfiConverterSequenceDouble.allocationSize(value.`xTicks`) +
            FfiConverterSequenceDouble.allocationSize(value.`yTicks`) +
            FfiConverterTypeDiagramScale.allocationSize(value.`scale`) +
            FfiConverterDouble.allocationSize(value.`maxGamma`) +
            FfiConverterDouble.allocationSize(value.`plotWidth`) +
            FfiConverterDouble.allocationSize(value.`plotHeight`) +
            FfiConverterDouble.allocationSize(value.`marginLeft`) +
            FfiConverterDouble.allocationSize(value.`marginTop`)
    )

    override fun write(value: CartesianDiagramData, buf: ByteBuffer) {
            FfiConverterSequenceTypeCartesianCurve.write(value.`curves`, buf)
            FfiConverterSequenceDouble.write(value.`xTicks`, buf)
            FfiConverterSequenceDouble.write(value.`yTicks`, buf)
            FfiConverterTypeDiagramScale.write(value.`scale`, buf)
            FfiConverterDouble.write(value.`maxGamma`, buf)
            FfiConverterDouble.write(value.`plotWidth`, buf)
            FfiConverterDouble.write(value.`plotHeight`, buf)
            FfiConverterDouble.write(value.`marginLeft`, buf)
            FfiConverterDouble.write(value.`marginTop`, buf)
    }
}



data class CartesianPoint (
    var `x`: kotlin.Double, 
    var `y`: kotlin.Double, 
    var `gamma`: kotlin.Double, 
    var `intensity`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCartesianPoint: FfiConverterRustBuffer<CartesianPoint> {
    override fun read(buf: ByteBuffer): CartesianPoint {
        return CartesianPoint(
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: CartesianPoint) = (
            FfiConverterDouble.allocationSize(value.`x`) +
            FfiConverterDouble.allocationSize(value.`y`) +
            FfiConverterDouble.allocationSize(value.`gamma`) +
            FfiConverterDouble.allocationSize(value.`intensity`)
    )

    override fun write(value: CartesianPoint, buf: ByteBuffer) {
            FfiConverterDouble.write(value.`x`, buf)
            FfiConverterDouble.write(value.`y`, buf)
            FfiConverterDouble.write(value.`gamma`, buf)
            FfiConverterDouble.write(value.`intensity`, buf)
    }
}



data class Color (
    var `r`: kotlin.UByte, 
    var `g`: kotlin.UByte, 
    var `b`: kotlin.UByte
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeColor: FfiConverterRustBuffer<Color> {
    override fun read(buf: ByteBuffer): Color {
        return Color(
            FfiConverterUByte.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterUByte.read(buf),
        )
    }

    override fun allocationSize(value: Color) = (
            FfiConverterUByte.allocationSize(value.`r`) +
            FfiConverterUByte.allocationSize(value.`g`) +
            FfiConverterUByte.allocationSize(value.`b`)
    )

    override fun write(value: Color, buf: ByteBuffer) {
            FfiConverterUByte.write(value.`r`, buf)
            FfiConverterUByte.write(value.`g`, buf)
            FfiConverterUByte.write(value.`b`, buf)
    }
}



/**
 * Result of converting a single file
 */
data class ConversionResult (
    var `inputPath`: kotlin.String, 
    var `outputPath`: kotlin.String, 
    var `success`: kotlin.Boolean, 
    var `errorMessage`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConversionResult: FfiConverterRustBuffer<ConversionResult> {
    override fun read(buf: ByteBuffer): ConversionResult {
        return ConversionResult(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: ConversionResult) = (
            FfiConverterString.allocationSize(value.`inputPath`) +
            FfiConverterString.allocationSize(value.`outputPath`) +
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterOptionalString.allocationSize(value.`errorMessage`)
    )

    override fun write(value: ConversionResult, buf: ByteBuffer) {
            FfiConverterString.write(value.`inputPath`, buf)
            FfiConverterString.write(value.`outputPath`, buf)
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterOptionalString.write(value.`errorMessage`, buf)
    }
}



data class DiagramScale (
    var `maxIntensity`: kotlin.Double, 
    var `scaleMax`: kotlin.Double, 
    var `gridValues`: List<kotlin.Double>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDiagramScale: FfiConverterRustBuffer<DiagramScale> {
    override fun read(buf: ByteBuffer): DiagramScale {
        return DiagramScale(
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterSequenceDouble.read(buf),
        )
    }

    override fun allocationSize(value: DiagramScale) = (
            FfiConverterDouble.allocationSize(value.`maxIntensity`) +
            FfiConverterDouble.allocationSize(value.`scaleMax`) +
            FfiConverterSequenceDouble.allocationSize(value.`gridValues`)
    )

    override fun write(value: DiagramScale, buf: ByteBuffer) {
            FfiConverterDouble.write(value.`maxIntensity`, buf)
            FfiConverterDouble.write(value.`scaleMax`, buf)
            FfiConverterSequenceDouble.write(value.`gridValues`, buf)
    }
}



data class Eulumdat (
    var `identification`: kotlin.String, 
    var `typeIndicator`: TypeIndicator, 
    var `symmetry`: Symmetry, 
    var `numCPlanes`: kotlin.UInt, 
    var `cPlaneDistance`: kotlin.Double, 
    var `numGPlanes`: kotlin.UInt, 
    var `gPlaneDistance`: kotlin.Double, 
    var `measurementReportNumber`: kotlin.String, 
    var `luminaireName`: kotlin.String, 
    var `luminaireNumber`: kotlin.String, 
    var `fileName`: kotlin.String, 
    var `dateUser`: kotlin.String, 
    var `length`: kotlin.Double, 
    var `width`: kotlin.Double, 
    var `height`: kotlin.Double, 
    var `luminousAreaLength`: kotlin.Double, 
    var `luminousAreaWidth`: kotlin.Double, 
    var `heightC0`: kotlin.Double, 
    var `heightC90`: kotlin.Double, 
    var `heightC180`: kotlin.Double, 
    var `heightC270`: kotlin.Double, 
    var `downwardFluxFraction`: kotlin.Double, 
    var `lightOutputRatio`: kotlin.Double, 
    var `conversionFactor`: kotlin.Double, 
    var `tiltAngle`: kotlin.Double, 
    var `lampSets`: List<LampSet>, 
    var `directRatios`: List<kotlin.Double>, 
    var `cAngles`: List<kotlin.Double>, 
    var `gAngles`: List<kotlin.Double>, 
    var `intensities`: List<List<kotlin.Double>>, 
    var `maxIntensity`: kotlin.Double, 
    var `totalLuminousFlux`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEulumdat: FfiConverterRustBuffer<Eulumdat> {
    override fun read(buf: ByteBuffer): Eulumdat {
        return Eulumdat(
            FfiConverterString.read(buf),
            FfiConverterTypeTypeIndicator.read(buf),
            FfiConverterTypeSymmetry.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterSequenceTypeLampSet.read(buf),
            FfiConverterSequenceDouble.read(buf),
            FfiConverterSequenceDouble.read(buf),
            FfiConverterSequenceDouble.read(buf),
            FfiConverterSequenceSequenceDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: Eulumdat) = (
            FfiConverterString.allocationSize(value.`identification`) +
            FfiConverterTypeTypeIndicator.allocationSize(value.`typeIndicator`) +
            FfiConverterTypeSymmetry.allocationSize(value.`symmetry`) +
            FfiConverterUInt.allocationSize(value.`numCPlanes`) +
            FfiConverterDouble.allocationSize(value.`cPlaneDistance`) +
            FfiConverterUInt.allocationSize(value.`numGPlanes`) +
            FfiConverterDouble.allocationSize(value.`gPlaneDistance`) +
            FfiConverterString.allocationSize(value.`measurementReportNumber`) +
            FfiConverterString.allocationSize(value.`luminaireName`) +
            FfiConverterString.allocationSize(value.`luminaireNumber`) +
            FfiConverterString.allocationSize(value.`fileName`) +
            FfiConverterString.allocationSize(value.`dateUser`) +
            FfiConverterDouble.allocationSize(value.`length`) +
            FfiConverterDouble.allocationSize(value.`width`) +
            FfiConverterDouble.allocationSize(value.`height`) +
            FfiConverterDouble.allocationSize(value.`luminousAreaLength`) +
            FfiConverterDouble.allocationSize(value.`luminousAreaWidth`) +
            FfiConverterDouble.allocationSize(value.`heightC0`) +
            FfiConverterDouble.allocationSize(value.`heightC90`) +
            FfiConverterDouble.allocationSize(value.`heightC180`) +
            FfiConverterDouble.allocationSize(value.`heightC270`) +
            FfiConverterDouble.allocationSize(value.`downwardFluxFraction`) +
            FfiConverterDouble.allocationSize(value.`lightOutputRatio`) +
            FfiConverterDouble.allocationSize(value.`conversionFactor`) +
            FfiConverterDouble.allocationSize(value.`tiltAngle`) +
            FfiConverterSequenceTypeLampSet.allocationSize(value.`lampSets`) +
            FfiConverterSequenceDouble.allocationSize(value.`directRatios`) +
            FfiConverterSequenceDouble.allocationSize(value.`cAngles`) +
            FfiConverterSequenceDouble.allocationSize(value.`gAngles`) +
            FfiConverterSequenceSequenceDouble.allocationSize(value.`intensities`) +
            FfiConverterDouble.allocationSize(value.`maxIntensity`) +
            FfiConverterDouble.allocationSize(value.`totalLuminousFlux`)
    )

    override fun write(value: Eulumdat, buf: ByteBuffer) {
            FfiConverterString.write(value.`identification`, buf)
            FfiConverterTypeTypeIndicator.write(value.`typeIndicator`, buf)
            FfiConverterTypeSymmetry.write(value.`symmetry`, buf)
            FfiConverterUInt.write(value.`numCPlanes`, buf)
            FfiConverterDouble.write(value.`cPlaneDistance`, buf)
            FfiConverterUInt.write(value.`numGPlanes`, buf)
            FfiConverterDouble.write(value.`gPlaneDistance`, buf)
            FfiConverterString.write(value.`measurementReportNumber`, buf)
            FfiConverterString.write(value.`luminaireName`, buf)
            FfiConverterString.write(value.`luminaireNumber`, buf)
            FfiConverterString.write(value.`fileName`, buf)
            FfiConverterString.write(value.`dateUser`, buf)
            FfiConverterDouble.write(value.`length`, buf)
            FfiConverterDouble.write(value.`width`, buf)
            FfiConverterDouble.write(value.`height`, buf)
            FfiConverterDouble.write(value.`luminousAreaLength`, buf)
            FfiConverterDouble.write(value.`luminousAreaWidth`, buf)
            FfiConverterDouble.write(value.`heightC0`, buf)
            FfiConverterDouble.write(value.`heightC90`, buf)
            FfiConverterDouble.write(value.`heightC180`, buf)
            FfiConverterDouble.write(value.`heightC270`, buf)
            FfiConverterDouble.write(value.`downwardFluxFraction`, buf)
            FfiConverterDouble.write(value.`lightOutputRatio`, buf)
            FfiConverterDouble.write(value.`conversionFactor`, buf)
            FfiConverterDouble.write(value.`tiltAngle`, buf)
            FfiConverterSequenceTypeLampSet.write(value.`lampSets`, buf)
            FfiConverterSequenceDouble.write(value.`directRatios`, buf)
            FfiConverterSequenceDouble.write(value.`cAngles`, buf)
            FfiConverterSequenceDouble.write(value.`gAngles`, buf)
            FfiConverterSequenceSequenceDouble.write(value.`intensities`, buf)
            FfiConverterDouble.write(value.`maxIntensity`, buf)
            FfiConverterDouble.write(value.`totalLuminousFlux`, buf)
    }
}



data class HeatmapCell (
    var `cIndex`: kotlin.UInt, 
    var `gIndex`: kotlin.UInt, 
    var `cAngle`: kotlin.Double, 
    var `gAngle`: kotlin.Double, 
    var `intensity`: kotlin.Double, 
    var `candela`: kotlin.Double, 
    var `normalized`: kotlin.Double, 
    var `color`: Color, 
    var `x`: kotlin.Double, 
    var `y`: kotlin.Double, 
    var `width`: kotlin.Double, 
    var `height`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeHeatmapCell: FfiConverterRustBuffer<HeatmapCell> {
    override fun read(buf: ByteBuffer): HeatmapCell {
        return HeatmapCell(
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterTypeColor.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: HeatmapCell) = (
            FfiConverterUInt.allocationSize(value.`cIndex`) +
            FfiConverterUInt.allocationSize(value.`gIndex`) +
            FfiConverterDouble.allocationSize(value.`cAngle`) +
            FfiConverterDouble.allocationSize(value.`gAngle`) +
            FfiConverterDouble.allocationSize(value.`intensity`) +
            FfiConverterDouble.allocationSize(value.`candela`) +
            FfiConverterDouble.allocationSize(value.`normalized`) +
            FfiConverterTypeColor.allocationSize(value.`color`) +
            FfiConverterDouble.allocationSize(value.`x`) +
            FfiConverterDouble.allocationSize(value.`y`) +
            FfiConverterDouble.allocationSize(value.`width`) +
            FfiConverterDouble.allocationSize(value.`height`)
    )

    override fun write(value: HeatmapCell, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`cIndex`, buf)
            FfiConverterUInt.write(value.`gIndex`, buf)
            FfiConverterDouble.write(value.`cAngle`, buf)
            FfiConverterDouble.write(value.`gAngle`, buf)
            FfiConverterDouble.write(value.`intensity`, buf)
            FfiConverterDouble.write(value.`candela`, buf)
            FfiConverterDouble.write(value.`normalized`, buf)
            FfiConverterTypeColor.write(value.`color`, buf)
            FfiConverterDouble.write(value.`x`, buf)
            FfiConverterDouble.write(value.`y`, buf)
            FfiConverterDouble.write(value.`width`, buf)
            FfiConverterDouble.write(value.`height`, buf)
    }
}



data class HeatmapDiagramData (
    var `cells`: List<HeatmapCell>, 
    var `scale`: DiagramScale, 
    var `maxCandela`: kotlin.Double, 
    var `totalFlux`: kotlin.Double, 
    var `cAngles`: List<kotlin.Double>, 
    var `gAngles`: List<kotlin.Double>, 
    var `legendEntries`: List<LegendEntry>, 
    var `plotWidth`: kotlin.Double, 
    var `plotHeight`: kotlin.Double, 
    var `marginLeft`: kotlin.Double, 
    var `marginTop`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeHeatmapDiagramData: FfiConverterRustBuffer<HeatmapDiagramData> {
    override fun read(buf: ByteBuffer): HeatmapDiagramData {
        return HeatmapDiagramData(
            FfiConverterSequenceTypeHeatmapCell.read(buf),
            FfiConverterTypeDiagramScale.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterSequenceDouble.read(buf),
            FfiConverterSequenceDouble.read(buf),
            FfiConverterSequenceTypeLegendEntry.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: HeatmapDiagramData) = (
            FfiConverterSequenceTypeHeatmapCell.allocationSize(value.`cells`) +
            FfiConverterTypeDiagramScale.allocationSize(value.`scale`) +
            FfiConverterDouble.allocationSize(value.`maxCandela`) +
            FfiConverterDouble.allocationSize(value.`totalFlux`) +
            FfiConverterSequenceDouble.allocationSize(value.`cAngles`) +
            FfiConverterSequenceDouble.allocationSize(value.`gAngles`) +
            FfiConverterSequenceTypeLegendEntry.allocationSize(value.`legendEntries`) +
            FfiConverterDouble.allocationSize(value.`plotWidth`) +
            FfiConverterDouble.allocationSize(value.`plotHeight`) +
            FfiConverterDouble.allocationSize(value.`marginLeft`) +
            FfiConverterDouble.allocationSize(value.`marginTop`)
    )

    override fun write(value: HeatmapDiagramData, buf: ByteBuffer) {
            FfiConverterSequenceTypeHeatmapCell.write(value.`cells`, buf)
            FfiConverterTypeDiagramScale.write(value.`scale`, buf)
            FfiConverterDouble.write(value.`maxCandela`, buf)
            FfiConverterDouble.write(value.`totalFlux`, buf)
            FfiConverterSequenceDouble.write(value.`cAngles`, buf)
            FfiConverterSequenceDouble.write(value.`gAngles`, buf)
            FfiConverterSequenceTypeLegendEntry.write(value.`legendEntries`, buf)
            FfiConverterDouble.write(value.`plotWidth`, buf)
            FfiConverterDouble.write(value.`plotHeight`, buf)
            FfiConverterDouble.write(value.`marginLeft`, buf)
            FfiConverterDouble.write(value.`marginTop`, buf)
    }
}



data class LampSet (
    var `numLamps`: kotlin.Int, 
    var `lampType`: kotlin.String, 
    var `totalLuminousFlux`: kotlin.Double, 
    var `colorAppearance`: kotlin.String, 
    var `colorRenderingGroup`: kotlin.String, 
    var `wattageWithBallast`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLampSet: FfiConverterRustBuffer<LampSet> {
    override fun read(buf: ByteBuffer): LampSet {
        return LampSet(
            FfiConverterInt.read(buf),
            FfiConverterString.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: LampSet) = (
            FfiConverterInt.allocationSize(value.`numLamps`) +
            FfiConverterString.allocationSize(value.`lampType`) +
            FfiConverterDouble.allocationSize(value.`totalLuminousFlux`) +
            FfiConverterString.allocationSize(value.`colorAppearance`) +
            FfiConverterString.allocationSize(value.`colorRenderingGroup`) +
            FfiConverterDouble.allocationSize(value.`wattageWithBallast`)
    )

    override fun write(value: LampSet, buf: ByteBuffer) {
            FfiConverterInt.write(value.`numLamps`, buf)
            FfiConverterString.write(value.`lampType`, buf)
            FfiConverterDouble.write(value.`totalLuminousFlux`, buf)
            FfiConverterString.write(value.`colorAppearance`, buf)
            FfiConverterString.write(value.`colorRenderingGroup`, buf)
            FfiConverterDouble.write(value.`wattageWithBallast`, buf)
    }
}



data class LegendEntry (
    var `normalized`: kotlin.Double, 
    var `color`: Color, 
    var `candela`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLegendEntry: FfiConverterRustBuffer<LegendEntry> {
    override fun read(buf: ByteBuffer): LegendEntry {
        return LegendEntry(
            FfiConverterDouble.read(buf),
            FfiConverterTypeColor.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: LegendEntry) = (
            FfiConverterDouble.allocationSize(value.`normalized`) +
            FfiConverterTypeColor.allocationSize(value.`color`) +
            FfiConverterDouble.allocationSize(value.`candela`)
    )

    override fun write(value: LegendEntry, buf: ByteBuffer) {
            FfiConverterDouble.write(value.`normalized`, buf)
            FfiConverterTypeColor.write(value.`color`, buf)
            FfiConverterDouble.write(value.`candela`, buf)
    }
}



data class Point2D (
    var `x`: kotlin.Double, 
    var `y`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePoint2D: FfiConverterRustBuffer<Point2D> {
    override fun read(buf: ByteBuffer): Point2D {
        return Point2D(
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: Point2D) = (
            FfiConverterDouble.allocationSize(value.`x`) +
            FfiConverterDouble.allocationSize(value.`y`)
    )

    override fun write(value: Point2D, buf: ByteBuffer) {
            FfiConverterDouble.write(value.`x`, buf)
            FfiConverterDouble.write(value.`y`, buf)
    }
}



data class PolarCurve (
    var `points`: List<PolarPoint>, 
    var `cAngle`: kotlin.Double, 
    var `label`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePolarCurve: FfiConverterRustBuffer<PolarCurve> {
    override fun read(buf: ByteBuffer): PolarCurve {
        return PolarCurve(
            FfiConverterSequenceTypePolarPoint.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PolarCurve) = (
            FfiConverterSequenceTypePolarPoint.allocationSize(value.`points`) +
            FfiConverterDouble.allocationSize(value.`cAngle`) +
            FfiConverterString.allocationSize(value.`label`)
    )

    override fun write(value: PolarCurve, buf: ByteBuffer) {
            FfiConverterSequenceTypePolarPoint.write(value.`points`, buf)
            FfiConverterDouble.write(value.`cAngle`, buf)
            FfiConverterString.write(value.`label`, buf)
    }
}



data class PolarDiagramData (
    var `c0C180Curve`: PolarCurve, 
    var `c90C270Curve`: PolarCurve, 
    var `scale`: DiagramScale, 
    var `symmetry`: Symmetry, 
    var `showC90C270`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePolarDiagramData: FfiConverterRustBuffer<PolarDiagramData> {
    override fun read(buf: ByteBuffer): PolarDiagramData {
        return PolarDiagramData(
            FfiConverterTypePolarCurve.read(buf),
            FfiConverterTypePolarCurve.read(buf),
            FfiConverterTypeDiagramScale.read(buf),
            FfiConverterTypeSymmetry.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: PolarDiagramData) = (
            FfiConverterTypePolarCurve.allocationSize(value.`c0C180Curve`) +
            FfiConverterTypePolarCurve.allocationSize(value.`c90C270Curve`) +
            FfiConverterTypeDiagramScale.allocationSize(value.`scale`) +
            FfiConverterTypeSymmetry.allocationSize(value.`symmetry`) +
            FfiConverterBoolean.allocationSize(value.`showC90C270`)
    )

    override fun write(value: PolarDiagramData, buf: ByteBuffer) {
            FfiConverterTypePolarCurve.write(value.`c0C180Curve`, buf)
            FfiConverterTypePolarCurve.write(value.`c90C270Curve`, buf)
            FfiConverterTypeDiagramScale.write(value.`scale`, buf)
            FfiConverterTypeSymmetry.write(value.`symmetry`, buf)
            FfiConverterBoolean.write(value.`showC90C270`, buf)
    }
}



data class PolarPoint (
    var `x`: kotlin.Double, 
    var `y`: kotlin.Double, 
    var `gamma`: kotlin.Double, 
    var `intensity`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePolarPoint: FfiConverterRustBuffer<PolarPoint> {
    override fun read(buf: ByteBuffer): PolarPoint {
        return PolarPoint(
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: PolarPoint) = (
            FfiConverterDouble.allocationSize(value.`x`) +
            FfiConverterDouble.allocationSize(value.`y`) +
            FfiConverterDouble.allocationSize(value.`gamma`) +
            FfiConverterDouble.allocationSize(value.`intensity`)
    )

    override fun write(value: PolarPoint, buf: ByteBuffer) {
            FfiConverterDouble.write(value.`x`, buf)
            FfiConverterDouble.write(value.`y`, buf)
            FfiConverterDouble.write(value.`gamma`, buf)
            FfiConverterDouble.write(value.`intensity`, buf)
    }
}



/**
 * A validation error (fatal issue)
 */
data class ValidationError (
    /**
     * Error code for programmatic handling
     */
    var `code`: kotlin.String, 
    /**
     * Human-readable error message
     */
    var `message`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeValidationError: FfiConverterRustBuffer<ValidationError> {
    override fun read(buf: ByteBuffer): ValidationError {
        return ValidationError(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ValidationError) = (
            FfiConverterString.allocationSize(value.`code`) +
            FfiConverterString.allocationSize(value.`message`)
    )

    override fun write(value: ValidationError, buf: ByteBuffer) {
            FfiConverterString.write(value.`code`, buf)
            FfiConverterString.write(value.`message`, buf)
    }
}



/**
 * A validation warning (non-fatal issue)
 */
data class ValidationWarning (
    /**
     * Warning code for programmatic handling
     */
    var `code`: kotlin.String, 
    /**
     * Human-readable warning message
     */
    var `message`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeValidationWarning: FfiConverterRustBuffer<ValidationWarning> {
    override fun read(buf: ByteBuffer): ValidationWarning {
        return ValidationWarning(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ValidationWarning) = (
            FfiConverterString.allocationSize(value.`code`) +
            FfiConverterString.allocationSize(value.`message`)
    )

    override fun write(value: ValidationWarning, buf: ByteBuffer) {
            FfiConverterString.write(value.`code`, buf)
            FfiConverterString.write(value.`message`, buf)
    }
}



/**
 * Custom watch face style configuration
 */
data class WatchFaceStyleCustom (
    /**
     * Background color (use "transparent" for PNG with alpha)
     */
    var `background`: kotlin.String, 
    /**
     * Grid/hour marker color
     */
    var `gridColor`: kotlin.String, 
    /**
     * Main curve color (C0-C180)
     */
    var `curvePrimary`: kotlin.String, 
    /**
     * Secondary curve color (C90-C270)
     */
    var `curveSecondary`: kotlin.String, 
    /**
     * Fill opacity for curves (0.0-1.0)
     */
    var `fillOpacity`: kotlin.Double, 
    /**
     * Whether to show hour markers (12, 3, 6, 9)
     */
    var `showHourMarkers`: kotlin.Boolean, 
    /**
     * Whether to show minute tick marks
     */
    var `showMinuteTicks`: kotlin.Boolean, 
    /**
     * Whether to show the secondary (C90-C270) curve
     */
    var `showSecondaryCurve`: kotlin.Boolean, 
    /**
     * Stroke width for curves
     */
    var `curveStrokeWidth`: kotlin.Double, 
    /**
     * Grid line width
     */
    var `gridStrokeWidth`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWatchFaceStyleCustom: FfiConverterRustBuffer<WatchFaceStyleCustom> {
    override fun read(buf: ByteBuffer): WatchFaceStyleCustom {
        return WatchFaceStyleCustom(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: WatchFaceStyleCustom) = (
            FfiConverterString.allocationSize(value.`background`) +
            FfiConverterString.allocationSize(value.`gridColor`) +
            FfiConverterString.allocationSize(value.`curvePrimary`) +
            FfiConverterString.allocationSize(value.`curveSecondary`) +
            FfiConverterDouble.allocationSize(value.`fillOpacity`) +
            FfiConverterBoolean.allocationSize(value.`showHourMarkers`) +
            FfiConverterBoolean.allocationSize(value.`showMinuteTicks`) +
            FfiConverterBoolean.allocationSize(value.`showSecondaryCurve`) +
            FfiConverterDouble.allocationSize(value.`curveStrokeWidth`) +
            FfiConverterDouble.allocationSize(value.`gridStrokeWidth`)
    )

    override fun write(value: WatchFaceStyleCustom, buf: ByteBuffer) {
            FfiConverterString.write(value.`background`, buf)
            FfiConverterString.write(value.`gridColor`, buf)
            FfiConverterString.write(value.`curvePrimary`, buf)
            FfiConverterString.write(value.`curveSecondary`, buf)
            FfiConverterDouble.write(value.`fillOpacity`, buf)
            FfiConverterBoolean.write(value.`showHourMarkers`, buf)
            FfiConverterBoolean.write(value.`showMinuteTicks`, buf)
            FfiConverterBoolean.write(value.`showSecondaryCurve`, buf)
            FfiConverterDouble.write(value.`curveStrokeWidth`, buf)
            FfiConverterDouble.write(value.`gridStrokeWidth`, buf)
    }
}



/**
 * Zone lumens data for BUG rating
 */
data class ZoneLumens (
    var `bl`: kotlin.Double, 
    var `bm`: kotlin.Double, 
    var `bh`: kotlin.Double, 
    var `bvh`: kotlin.Double, 
    var `fl`: kotlin.Double, 
    var `fm`: kotlin.Double, 
    var `fh`: kotlin.Double, 
    var `fvh`: kotlin.Double, 
    var `ul`: kotlin.Double, 
    var `uh`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeZoneLumens: FfiConverterRustBuffer<ZoneLumens> {
    override fun read(buf: ByteBuffer): ZoneLumens {
        return ZoneLumens(
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: ZoneLumens) = (
            FfiConverterDouble.allocationSize(value.`bl`) +
            FfiConverterDouble.allocationSize(value.`bm`) +
            FfiConverterDouble.allocationSize(value.`bh`) +
            FfiConverterDouble.allocationSize(value.`bvh`) +
            FfiConverterDouble.allocationSize(value.`fl`) +
            FfiConverterDouble.allocationSize(value.`fm`) +
            FfiConverterDouble.allocationSize(value.`fh`) +
            FfiConverterDouble.allocationSize(value.`fvh`) +
            FfiConverterDouble.allocationSize(value.`ul`) +
            FfiConverterDouble.allocationSize(value.`uh`)
    )

    override fun write(value: ZoneLumens, buf: ByteBuffer) {
            FfiConverterDouble.write(value.`bl`, buf)
            FfiConverterDouble.write(value.`bm`, buf)
            FfiConverterDouble.write(value.`bh`, buf)
            FfiConverterDouble.write(value.`bvh`, buf)
            FfiConverterDouble.write(value.`fl`, buf)
            FfiConverterDouble.write(value.`fm`, buf)
            FfiConverterDouble.write(value.`fh`, buf)
            FfiConverterDouble.write(value.`fvh`, buf)
            FfiConverterDouble.write(value.`ul`, buf)
            FfiConverterDouble.write(value.`uh`, buf)
    }
}



/**
 * Output format for batch conversion
 */

enum class ConversionFormat {
    
    IES,
    LDT;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeConversionFormat: FfiConverterRustBuffer<ConversionFormat> {
    override fun read(buf: ByteBuffer) = try {
        ConversionFormat.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ConversionFormat) = 4UL

    override fun write(value: ConversionFormat, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * Error type for FFI
 */
sealed class EulumdatException: kotlin.Exception() {
    
    class ParseException(
        
        val v1: kotlin.String
        ) : EulumdatException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ValidationException(
        
        val v1: kotlin.String
        ) : EulumdatException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class IoException(
        
        val v1: kotlin.String
        ) : EulumdatException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<EulumdatException> {
        override fun lift(error_buf: RustBuffer.ByValue): EulumdatException = FfiConverterTypeEulumdatError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeEulumdatError : FfiConverterRustBuffer<EulumdatException> {
    override fun read(buf: ByteBuffer): EulumdatException {
        

        return when(buf.getInt()) {
            1 -> EulumdatException.ParseException(
                FfiConverterString.read(buf),
                )
            2 -> EulumdatException.ValidationException(
                FfiConverterString.read(buf),
                )
            3 -> EulumdatException.IoException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: EulumdatException): ULong {
        return when(value) {
            is EulumdatException.ParseException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is EulumdatException.ValidationException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is EulumdatException.IoException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: EulumdatException, buf: ByteBuffer) {
        when(value) {
            is EulumdatException.ParseException -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is EulumdatException.ValidationException -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is EulumdatException.IoException -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



/**
 * Input file format
 */

enum class InputFormat {
    
    LDT,
    IES;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeInputFormat: FfiConverterRustBuffer<InputFormat> {
    override fun read(buf: ByteBuffer) = try {
        InputFormat.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: InputFormat) = 4UL

    override fun write(value: InputFormat, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class SvgThemeType {
    
    LIGHT,
    DARK,
    CSS_VARIABLES;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSvgThemeType: FfiConverterRustBuffer<SvgThemeType> {
    override fun read(buf: ByteBuffer) = try {
        SvgThemeType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SvgThemeType) = 4UL

    override fun write(value: SvgThemeType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class Symmetry {
    
    NONE,
    VERTICAL_AXIS,
    PLANE_C0C180,
    PLANE_C90C270,
    BOTH_PLANES;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSymmetry: FfiConverterRustBuffer<Symmetry> {
    override fun read(buf: ByteBuffer) = try {
        Symmetry.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: Symmetry) = 4UL

    override fun write(value: Symmetry, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class TypeIndicator {
    
    POINT_SOURCE_SYMMETRIC,
    LINEAR,
    POINT_SOURCE_OTHER;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeTypeIndicator: FfiConverterRustBuffer<TypeIndicator> {
    override fun read(buf: ByteBuffer) = try {
        TypeIndicator.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: TypeIndicator) = 4UL

    override fun write(value: TypeIndicator, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Watch face style preset
 */

enum class WatchFaceStyleType {
    
    /**
     * Dark style with cyan curves (default)
     */
    DARK,
    /**
     * Light style with blue curves
     */
    LIGHT,
    /**
     * Minimal style - curves only, less grid
     */
    MINIMAL,
    /**
     * Complication style - optimized for 120x120
     */
    COMPLICATION,
    /**
     * California style - warm amber tones
     */
    CALIFORNIA;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeWatchFaceStyleType: FfiConverterRustBuffer<WatchFaceStyleType> {
    override fun read(buf: ByteBuffer) = try {
        WatchFaceStyleType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: WatchFaceStyleType) = 4UL

    override fun write(value: WatchFaceStyleType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






/**
 * @suppress
 */
public object FfiConverterOptionalString: FfiConverterRustBuffer<kotlin.String?> {
    override fun read(buf: ByteBuffer): kotlin.String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: kotlin.String?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: kotlin.String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeInputFormat: FfiConverterRustBuffer<InputFormat?> {
    override fun read(buf: ByteBuffer): InputFormat? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeInputFormat.read(buf)
    }

    override fun allocationSize(value: InputFormat?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeInputFormat.allocationSize(value)
        }
    }

    override fun write(value: InputFormat?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeInputFormat.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceDouble: FfiConverterRustBuffer<List<kotlin.Double>> {
    override fun read(buf: ByteBuffer): List<kotlin.Double> {
        val len = buf.getInt()
        return List<kotlin.Double>(len) {
            FfiConverterDouble.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.Double>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterDouble.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.Double>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterDouble.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeBatchInputFile: FfiConverterRustBuffer<List<BatchInputFile>> {
    override fun read(buf: ByteBuffer): List<BatchInputFile> {
        val len = buf.getInt()
        return List<BatchInputFile>(len) {
            FfiConverterTypeBatchInputFile.read(buf)
        }
    }

    override fun allocationSize(value: List<BatchInputFile>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeBatchInputFile.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<BatchInputFile>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeBatchInputFile.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeBatchOutputFile: FfiConverterRustBuffer<List<BatchOutputFile>> {
    override fun read(buf: ByteBuffer): List<BatchOutputFile> {
        val len = buf.getInt()
        return List<BatchOutputFile>(len) {
            FfiConverterTypeBatchOutputFile.read(buf)
        }
    }

    override fun allocationSize(value: List<BatchOutputFile>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeBatchOutputFile.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<BatchOutputFile>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeBatchOutputFile.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeButterflyWing: FfiConverterRustBuffer<List<ButterflyWing>> {
    override fun read(buf: ByteBuffer): List<ButterflyWing> {
        val len = buf.getInt()
        return List<ButterflyWing>(len) {
            FfiConverterTypeButterflyWing.read(buf)
        }
    }

    override fun allocationSize(value: List<ButterflyWing>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeButterflyWing.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ButterflyWing>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeButterflyWing.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeCPlaneDirection: FfiConverterRustBuffer<List<CPlaneDirection>> {
    override fun read(buf: ByteBuffer): List<CPlaneDirection> {
        val len = buf.getInt()
        return List<CPlaneDirection>(len) {
            FfiConverterTypeCPlaneDirection.read(buf)
        }
    }

    override fun allocationSize(value: List<CPlaneDirection>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeCPlaneDirection.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<CPlaneDirection>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeCPlaneDirection.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeCartesianCurve: FfiConverterRustBuffer<List<CartesianCurve>> {
    override fun read(buf: ByteBuffer): List<CartesianCurve> {
        val len = buf.getInt()
        return List<CartesianCurve>(len) {
            FfiConverterTypeCartesianCurve.read(buf)
        }
    }

    override fun allocationSize(value: List<CartesianCurve>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeCartesianCurve.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<CartesianCurve>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeCartesianCurve.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeCartesianPoint: FfiConverterRustBuffer<List<CartesianPoint>> {
    override fun read(buf: ByteBuffer): List<CartesianPoint> {
        val len = buf.getInt()
        return List<CartesianPoint>(len) {
            FfiConverterTypeCartesianPoint.read(buf)
        }
    }

    override fun allocationSize(value: List<CartesianPoint>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeCartesianPoint.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<CartesianPoint>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeCartesianPoint.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeConversionResult: FfiConverterRustBuffer<List<ConversionResult>> {
    override fun read(buf: ByteBuffer): List<ConversionResult> {
        val len = buf.getInt()
        return List<ConversionResult>(len) {
            FfiConverterTypeConversionResult.read(buf)
        }
    }

    override fun allocationSize(value: List<ConversionResult>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeConversionResult.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ConversionResult>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeConversionResult.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeHeatmapCell: FfiConverterRustBuffer<List<HeatmapCell>> {
    override fun read(buf: ByteBuffer): List<HeatmapCell> {
        val len = buf.getInt()
        return List<HeatmapCell>(len) {
            FfiConverterTypeHeatmapCell.read(buf)
        }
    }

    override fun allocationSize(value: List<HeatmapCell>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeHeatmapCell.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<HeatmapCell>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeHeatmapCell.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeLampSet: FfiConverterRustBuffer<List<LampSet>> {
    override fun read(buf: ByteBuffer): List<LampSet> {
        val len = buf.getInt()
        return List<LampSet>(len) {
            FfiConverterTypeLampSet.read(buf)
        }
    }

    override fun allocationSize(value: List<LampSet>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeLampSet.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<LampSet>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeLampSet.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeLegendEntry: FfiConverterRustBuffer<List<LegendEntry>> {
    override fun read(buf: ByteBuffer): List<LegendEntry> {
        val len = buf.getInt()
        return List<LegendEntry>(len) {
            FfiConverterTypeLegendEntry.read(buf)
        }
    }

    override fun allocationSize(value: List<LegendEntry>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeLegendEntry.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<LegendEntry>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeLegendEntry.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePoint2D: FfiConverterRustBuffer<List<Point2D>> {
    override fun read(buf: ByteBuffer): List<Point2D> {
        val len = buf.getInt()
        return List<Point2D>(len) {
            FfiConverterTypePoint2D.read(buf)
        }
    }

    override fun allocationSize(value: List<Point2D>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePoint2D.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Point2D>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePoint2D.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePolarPoint: FfiConverterRustBuffer<List<PolarPoint>> {
    override fun read(buf: ByteBuffer): List<PolarPoint> {
        val len = buf.getInt()
        return List<PolarPoint>(len) {
            FfiConverterTypePolarPoint.read(buf)
        }
    }

    override fun allocationSize(value: List<PolarPoint>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePolarPoint.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PolarPoint>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePolarPoint.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeValidationError: FfiConverterRustBuffer<List<ValidationError>> {
    override fun read(buf: ByteBuffer): List<ValidationError> {
        val len = buf.getInt()
        return List<ValidationError>(len) {
            FfiConverterTypeValidationError.read(buf)
        }
    }

    override fun allocationSize(value: List<ValidationError>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeValidationError.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ValidationError>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeValidationError.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeValidationWarning: FfiConverterRustBuffer<List<ValidationWarning>> {
    override fun read(buf: ByteBuffer): List<ValidationWarning> {
        val len = buf.getInt()
        return List<ValidationWarning>(len) {
            FfiConverterTypeValidationWarning.read(buf)
        }
    }

    override fun allocationSize(value: List<ValidationWarning>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeValidationWarning.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ValidationWarning>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeValidationWarning.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceSequenceDouble: FfiConverterRustBuffer<List<List<kotlin.Double>>> {
    override fun read(buf: ByteBuffer): List<List<kotlin.Double>> {
        val len = buf.getInt()
        return List<List<kotlin.Double>>(len) {
            FfiConverterSequenceDouble.read(buf)
        }
    }

    override fun allocationSize(value: List<List<kotlin.Double>>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterSequenceDouble.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<List<kotlin.Double>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterSequenceDouble.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceSequenceTypePoint2D: FfiConverterRustBuffer<List<List<Point2D>>> {
    override fun read(buf: ByteBuffer): List<List<Point2D>> {
        val len = buf.getInt()
        return List<List<Point2D>>(len) {
            FfiConverterSequenceTypePoint2D.read(buf)
        }
    }

    override fun allocationSize(value: List<List<Point2D>>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterSequenceTypePoint2D.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<List<Point2D>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterSequenceTypePoint2D.write(it, buf)
        }
    }
}
        /**
         * Batch convert and return the converted contents
         *
         * This is a thin FFI wrapper around eulumdat::batch::batch_convert()
         */ fun `batchConvertContents`(`files`: List<BatchInputFile>, `format`: ConversionFormat): List<BatchOutputFile> {
            return FfiConverterSequenceTypeBatchOutputFile.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_batch_convert_contents(
        FfiConverterSequenceTypeBatchInputFile.lower(`files`),FfiConverterTypeConversionFormat.lower(`format`),_status)
}
    )
    }
    

        /**
         * Batch convert multiple LDT contents to IES format
         * Returns a list of (original_name, ies_content or error)
         */ fun `batchConvertToIes`(`files`: List<BatchInputFile>): BatchConversionStats {
            return FfiConverterTypeBatchConversionStats.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_batch_convert_to_ies(
        FfiConverterSequenceTypeBatchInputFile.lower(`files`),_status)
}
    )
    }
    

        /**
         * Calculate BUG rating from Eulumdat data
         */ fun `calculateBugRating`(`ldt`: Eulumdat): BugRatingData {
            return FfiConverterTypeBugRatingData.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_calculate_bug_rating(
        FfiConverterTypeEulumdat.lower(`ldt`),_status)
}
    )
    }
    

        /**
         * Convert a single LDT file to IES format
         */
    @Throws(EulumdatException::class) fun `convertLdtToIes`(`ldtContent`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCallWithError(EulumdatException) { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_convert_ldt_to_ies(
        FfiConverterString.lower(`ldtContent`),_status)
}
    )
    }
    

        /**
         * Convert a single LDT file content to another LDT (normalize/clean)
         */
    @Throws(EulumdatException::class) fun `convertLdtToLdt`(`ldtContent`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCallWithError(EulumdatException) { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_convert_ldt_to_ldt(
        FfiConverterString.lower(`ldtContent`),_status)
}
    )
    }
    

        /**
         * Export Eulumdat data to IES format string
         */ fun `exportIes`(`ldt`: Eulumdat): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_export_ies(
        FfiConverterTypeEulumdat.lower(`ldt`),_status)
}
    )
    }
    

        /**
         * Export Eulumdat data to LDT format string
         */ fun `exportLdt`(`ldt`: Eulumdat): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_export_ldt(
        FfiConverterTypeEulumdat.lower(`ldt`),_status)
}
    )
    }
    

        /**
         * Generate BUG diagram data
         */ fun `generateBugDiagram`(`ldt`: Eulumdat): BugDiagramData {
            return FfiConverterTypeBugDiagramData.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_bug_diagram(
        FfiConverterTypeEulumdat.lower(`ldt`),_status)
}
    )
    }
    

        /**
         * Generate BUG rating diagram as SVG (TM-15-11 view)
         */ fun `generateBugSvg`(`ldt`: Eulumdat, `width`: kotlin.Double, `height`: kotlin.Double, `theme`: SvgThemeType): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_bug_svg(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterDouble.lower(`width`),FfiConverterDouble.lower(`height`),FfiConverterTypeSvgThemeType.lower(`theme`),_status)
}
    )
    }
    

        /**
         * Generate butterfly diagram data
         */ fun `generateButterflyDiagram`(`ldt`: Eulumdat, `width`: kotlin.Double, `height`: kotlin.Double, `tiltDegrees`: kotlin.Double): ButterflyDiagramData {
            return FfiConverterTypeButterflyDiagramData.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_butterfly_diagram(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterDouble.lower(`width`),FfiConverterDouble.lower(`height`),FfiConverterDouble.lower(`tiltDegrees`),_status)
}
    )
    }
    

        /**
         * Generate butterfly diagram as SVG string
         */ fun `generateButterflySvg`(`ldt`: Eulumdat, `width`: kotlin.Double, `height`: kotlin.Double, `tiltDegrees`: kotlin.Double, `theme`: SvgThemeType): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_butterfly_svg(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterDouble.lower(`width`),FfiConverterDouble.lower(`height`),FfiConverterDouble.lower(`tiltDegrees`),FfiConverterTypeSvgThemeType.lower(`theme`),_status)
}
    )
    }
    

        /**
         * Generate cartesian diagram data
         */ fun `generateCartesianDiagram`(`ldt`: Eulumdat, `width`: kotlin.Double, `height`: kotlin.Double, `maxCurves`: kotlin.UInt): CartesianDiagramData {
            return FfiConverterTypeCartesianDiagramData.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_cartesian_diagram(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterDouble.lower(`width`),FfiConverterDouble.lower(`height`),FfiConverterUInt.lower(`maxCurves`),_status)
}
    )
    }
    

        /**
         * Generate cartesian diagram as SVG string
         */ fun `generateCartesianSvg`(`ldt`: Eulumdat, `width`: kotlin.Double, `height`: kotlin.Double, `maxCurves`: kotlin.UInt, `theme`: SvgThemeType): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_cartesian_svg(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterDouble.lower(`width`),FfiConverterDouble.lower(`height`),FfiConverterUInt.lower(`maxCurves`),FfiConverterTypeSvgThemeType.lower(`theme`),_status)
}
    )
    }
    

        /**
         * Generate complication SVG (120x120 max for accessoryCircular)
         */ fun `generateComplicationSvg`(`ldt`: Eulumdat, `size`: kotlin.UInt): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_complication_svg(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterUInt.lower(`size`),_status)
}
    )
    }
    

        /**
         * Generate heatmap diagram data
         */ fun `generateHeatmapDiagram`(`ldt`: Eulumdat, `width`: kotlin.Double, `height`: kotlin.Double): HeatmapDiagramData {
            return FfiConverterTypeHeatmapDiagramData.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_heatmap_diagram(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterDouble.lower(`width`),FfiConverterDouble.lower(`height`),_status)
}
    )
    }
    

        /**
         * Generate heatmap diagram as SVG string
         */ fun `generateHeatmapSvg`(`ldt`: Eulumdat, `width`: kotlin.Double, `height`: kotlin.Double, `theme`: SvgThemeType): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_heatmap_svg(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterDouble.lower(`width`),FfiConverterDouble.lower(`height`),FfiConverterTypeSvgThemeType.lower(`theme`),_status)
}
    )
    }
    

        /**
         * Generate LCS diagram as SVG (TM-15-07 view)
         */ fun `generateLcsSvg`(`ldt`: Eulumdat, `width`: kotlin.Double, `height`: kotlin.Double, `theme`: SvgThemeType): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_lcs_svg(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterDouble.lower(`width`),FfiConverterDouble.lower(`height`),FfiConverterTypeSvgThemeType.lower(`theme`),_status)
}
    )
    }
    

        /**
         * Generate Photos face SVG (for Apple Watch Photos face background)
         *
         * # Arguments
         * * `ldt` - The luminaire data
         * * `width` - Width in pixels (e.g., 396 for 45mm)
         * * `height` - Height in pixels (e.g., 484 for 45mm)
         * * `style` - Watch face style preset
         */ fun `generatePhotosFaceSvg`(`ldt`: Eulumdat, `width`: kotlin.UInt, `height`: kotlin.UInt, `style`: WatchFaceStyleType): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_photos_face_svg(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterUInt.lower(`width`),FfiConverterUInt.lower(`height`),FfiConverterTypeWatchFaceStyleType.lower(`style`),_status)
}
    )
    }
    

        /**
         * Generate polar diagram data
         */ fun `generatePolarDiagram`(`ldt`: Eulumdat): PolarDiagramData {
            return FfiConverterTypePolarDiagramData.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_polar_diagram(
        FfiConverterTypeEulumdat.lower(`ldt`),_status)
}
    )
    }
    

        /**
         * Generate polar diagram as SVG string
         */ fun `generatePolarSvg`(`ldt`: Eulumdat, `width`: kotlin.Double, `height`: kotlin.Double, `theme`: SvgThemeType): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_polar_svg(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterDouble.lower(`width`),FfiConverterDouble.lower(`height`),FfiConverterTypeSvgThemeType.lower(`theme`),_status)
}
    )
    }
    

        /**
         * Generate watch face SVG with a preset style
         *
         * Creates a circular SVG suitable for Apple Watch faces.
         * The polar grid doubles as watch hour/minute markers.
         *
         * # Arguments
         * * `ldt` - The luminaire data
         * * `size` - Width and height in pixels (e.g., 396 for 45mm watch)
         * * `style` - Watch face style preset
         */ fun `generateWatchFaceSvg`(`ldt`: Eulumdat, `size`: kotlin.UInt, `style`: WatchFaceStyleType): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_watch_face_svg(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterUInt.lower(`size`),FfiConverterTypeWatchFaceStyleType.lower(`style`),_status)
}
    )
    }
    

        /**
         * Generate watch face SVG with a custom style
         */ fun `generateWatchFaceSvgCustom`(`ldt`: Eulumdat, `size`: kotlin.UInt, `style`: WatchFaceStyleCustom): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_generate_watch_face_svg_custom(
        FfiConverterTypeEulumdat.lower(`ldt`),FfiConverterUInt.lower(`size`),FfiConverterTypeWatchFaceStyleCustom.lower(`style`),_status)
}
    )
    }
    

        /**
         * Get detailed validation errors (for UI display)
         */ fun `getValidationErrors`(`ldt`: Eulumdat): List<ValidationError> {
            return FfiConverterSequenceTypeValidationError.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_get_validation_errors(
        FfiConverterTypeEulumdat.lower(`ldt`),_status)
}
    )
    }
    

        /**
         * Parse IES content and return an Eulumdat object
         */
    @Throws(EulumdatException::class) fun `parseIes`(`content`: kotlin.String): Eulumdat {
            return FfiConverterTypeEulumdat.lift(
    uniffiRustCallWithError(EulumdatException) { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_parse_ies(
        FfiConverterString.lower(`content`),_status)
}
    )
    }
    

        /**
         * Parse LDT content and return an Eulumdat object
         */
    @Throws(EulumdatException::class) fun `parseLdt`(`content`: kotlin.String): Eulumdat {
            return FfiConverterTypeEulumdat.lift(
    uniffiRustCallWithError(EulumdatException) { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_parse_ldt(
        FfiConverterString.lower(`content`),_status)
}
    )
    }
    

        /**
         * Validate Eulumdat data and return warnings
         */ fun `validateLdt`(`ldt`: Eulumdat): List<ValidationWarning> {
            return FfiConverterSequenceTypeValidationWarning.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_validate_ldt(
        FfiConverterTypeEulumdat.lower(`ldt`),_status)
}
    )
    }
    

        /**
         * Validate Eulumdat data strictly, returning errors if invalid
         */
    @Throws(EulumdatException::class) fun `validateLdtStrict`(`ldt`: Eulumdat)
        = 
    uniffiRustCallWithError(EulumdatException) { _status ->
    UniffiLib.INSTANCE.uniffi_eulumdat_ffi_fn_func_validate_ldt_strict(
        FfiConverterTypeEulumdat.lower(`ldt`),_status)
}
    
    


